\chapter{Zusammenfassung}
\section{Ausblick}
Hier einige Auflistung was aus zeitlichen Gründen noch nicht realisiert
wurde, die jedoch für den Einsatz in einem Projekt noch sehr wichtig wären.
Im folgendem eine Liste an fehlenden Features. Diese hat keinen Anspruch auf Vollständigkeit.
\subsubsection{Editor}
\begin{itemize}
	\item Joined-Inputs und auch Joined Outputs ( Das weiterreichen von einem Ergebnis an mehrere). Dies erfordert Möglicherweise noch einmal
	eine kleine Überarbeitung der Architekur des Models. Auch die Darstellung wurde noch nicht realisiert. Zusätzlich wird die Generierung etwas komplexer und wirft weitere Fragen auf eine eindeutige Interpretation auf.
	
	\item Validierung der Syntax - Markierung invalider Syntax innerhalb des Editors wurden nicht realisiert (z.B sind die Klammern richtig gesetzt).
	
	\item Search-Replace Funktionalität, um Datentypen oder andere Namen, die an vielen Stellen verwendet werden, schnell und  einfach umbenennen zu können.
	
	\item Mehr Möglichkeiten die Darstellung übersichtlicher zu gestalten: Auf und
	Zuklappen von Integrationen. Eine 'referenzierte' Kopie einer
	Funktionseinheit zu erstellen, um an anderer Stelle diese weiter zu
	verwenden.
	\item Saubere und eindeutige Darstellung einer Rekursion.
	\item Zuordnen von Funktionseinheiten zu Klassen.
	\item Möglichkeit mehrere Flow Design in einer Art Projekt zu Organisieren.
	Vielleicht auch in Form eines GUI-Skizzen-Editors, indem dann die
	Interaktionen eingetragen werden können.
	\item Autosave und Undo/Redo.
	\item Eine Möglichkeit große unübersaubare Flow Design in kleiner zu Aufzuteilen und diese an anderen Stelle zu definieren.

	
\end{itemize}


\subsubsection{Generierung von Code}
\begin{itemize}
	\item Übergabe einer Eigenschaft eines Objektes an eine Funktionseinheit.
	Bsp: product.Price -> CalculateDicount -> ...				 
	\item Zusammenführen von Datenströmen (Joined Inputs), in manchen Fällen fördert dass die Leserlichkeit.
	\item Weitere Möglichkeiten einführen um die Daten auf den Datenflüssen kurz und leserlicher zu halten.
	Zum Beispiel indem man  Aliase für Typen definieren kann, sodass man statt \texttt{breiten:int*} auch einfach nur \texttt{breiten} schreiben kann. 
	\item Registrieren  von neuen bekannten Datentypen, sodass diese nicht als \enquote{missing Datatypes} angezeigt werden und auch nicht 
	generiert werden, falls man diese doch in Dexel definiert.
	Wenn zum Beispiel aus einer externen Bibliothek  Klassen benutzt werden.
	\item Erkennen von vorhandenen Methoden aus der Standardbibliothek/LINQ, sodass für diese keine neuen Methoden erzeugt werden.
	Auch hier müsste man dann eine Notation einführen, um ausdrücken zu können, dass eine Methode des Objekts aufgerufen werden soll und nicht einer Methode das Objekt übergeben werden soll.	
\end{itemize}


\section{Fazit}

\subsubsection{Flow Design}
Mir persönlich gefällt IOSP sehr gut. Nach einer Eingewöhnungszeit lernte ich die Lambda-Schreibweise lieben und finde sie nun auch sehr leserlich. Der Code der sonst in vielen Unterfunktionen versteckt ist, kann so auf einen Blick überschaubar gehalten und trotzdem bleibt die Abstraktionsebene hoch. Ab einer gewissen Tiefe ist eine Aufteilung in unterschiedliche Methoden jedoch trotzdem sinnvoll.

Den Vorteil von entkoppelten Methoden lernte ich bereits im Dexel Projekt kennen. Methoden können leichter angepasst werden und an unterschiedlichen Stellen verwendet werden. Die Aufgabe einer Operation ist klar definiert, was sie einfacher zu implementieren und besser testbar macht. 

Die Tatsache, dass dadurch die Integrationen frei von Kontrollstrukturen bleiben finde ich auch gut. 
Leider gilt die Aussage, das die Integrationen dadurch leicht zu verstehen bleiben, da sie frei von \enquote{Logik} bleiben leider nicht immer. Wenn eine Operation zwei oder mehrere Ausgänge hat und diese in der Integration \enquote{verdrahtet} werden, so landet doch eine gute Portion Logik auch in den Integration und dadurch wird diese auch schwerer zu verstehen. 
Trotzdem würde ich weiter diese Art bevorzugen. Falls es mal nicht so sein sollte, steht es einem schließlich auch frei an jenen Stellen von der Regel abzuweichen.


Leider scheint diese Art zu programmieren  vorerst stark auf C\# ausgerichtet zu sein. In anderen Programmiersprachen, die ich kenne - wie Java und Python - besitzen diese nicht alle Funktionalitäten, die eine Umsetzung so leserlich erlauben, wie C\# \footnote{Möglicheweise gibt es andere Programmiersprachen, die es genauso gut oder vielleicht sogar noch besser ermöglichen, jedoch kenne ich persönlich aktuell keine }.
Fehlendes Closure für Lambdas ( in Python keine mehrzeiligen Lambda-Asdrücke)innerhalb eines Lambdas. 
Auch sind Java8 Streams lange nicht so mächtig und ausgereift wie LINQ. \footnote{Diese Aussage beruht darauf, dass LINQ in so gut wie jedem C\# Projekt an sehr vielen Stellen im Code zum Einsatz kommt, Java 8 Streams hingegen werden von den meisten Java-Entwickler gemieden, weil sie eben nicht so ausgereift sind. ( Laut Aussage von Kevin Erath über seine persönlichen Erfahrungen mit Java-Entwicklungsteams innerhalb der Firma)}

Leider habe bei der Umsetzung von IOSP innerhalb von Dexel so gut wie nie auf eine Flow Design Diagramm zurückgegriffen, stattdessen habe ich es innerhalb der IDE \enquote{herunterprogrammiert} und anschließend refaktorisiert. Der Hauptfaktor davon liegt für mich darin, dass mir eine IDE mit Intelisense mir oft viel arbeit erspart, gerade wenn bereits eine große Codebasis vorhanden ist.
Mit der Intelisense kann ich bereits vorhandene Mehoden auffinden und bekomme angezeigt, welche Parameter diese erwartet, oder in die Eigenschaften eines Objektes mit Auflistet.
All das habe ich auf dem Papier ( oder auch im akutellen Stand von Dexel nicht).



\subsubsection{Dexel}

Wie bereits erwähnt, habe ich beim Programmieren noch nicht so oft das Bedürfnis verspührt eine Flow Design Diagramm zu erstellen, wodurch ich mir die Sinnhaftigkeit eines Editors in Frage stellte.
Auch eine automatische Generierung  vollständig und ohne Fehler zu implementieren ist ein aufwendiges Unterfangen. Verglichen dazu ist der gewonnene Zeitaufwand  relativ gering. Die paar Zeilen der Integration kann man auch selbst relativ schnell heruntertippen, letzte Anpassungen vornehmen und dabei  auch LINQ  verwenden, um  auch komplexe Algorithmen runterzuscheiben.

 Es bedarf vielleicht erst einen perfekten Roundtrip, um eine automatische Generierung zu rechtfertigen und sinnvoll in einem Workflow mit einbinden zu können.
 
 Die Generierung könnte alternativ natürlich auf für Schulungszwecken verwendet werden, um Studenten/Entwicklern IOSP näherzubringen.
 
Auch ein Entwurf auf dem Papier hat immer noch einen gewissen Scharm und Einfachheit, die in Dexel noch nicht erreicht wurden.
Das mag vor allem daran liegen, dass noch nicht alle Notation im Editor umsetztbar sind (Joined Inputs). Einfach Pfeile von A zu B zu zeichenen ohne eine für den Computer Eindeutigkeit Interpretation zu achten auch seine Daseinsberechtigung ( und sich damit dann später bei der Übertragung in Code zu bschäftigen).

Dexel hat jedoch auch schon einige Vorteile gegenüber dem Entwurf auf dem Papier. Der erste ist Geschwindigkeit. 
Namen können auf der Tastatur schneller geschrieben werden, als auf mit dem Stift. Mit Hilfe von Shortcuts lassen sich schnell neue Funktionseinheiten hinten anhängen und so den Datenfluss schnell herunter schreiben.

Einfaches Duplizieren des Schaubildes und vorhandene Elemente neu anzuordnen und Texte abzuändern ist ein klarer Pluspunkt für Dexel.

Auch eine Validierung des Datenflusses kann vorteilhaft sein.



Der aktuelle Stand ist denke ich trotzdem ein guter Start geworden, der eine Vision aufzeigt, wie ein Editor für Flow Design aussehen könnte.
Mir persönlich fällt es schwer abzuschätzen im akutellen Stand des Projektes, on ein vollausgereifter Editor nicht doch einen  Platz finden könnte im \enquote{Werkzeugkasten} eines Softwareentwicklers.
 Es würde trotzdem noch einige Monate an in Anspruch nehmen,  um auf einen Stand zu kommen mit dem man sinnvoll Arbeiten kann und erst dann lässt sich sagen, wie sinnvoll er im Einsatz eines Softwareprojektes wirklich ist.
  Vielleicht ergibt es sich die Möglichkeit  im Rahmen einer Masterarbeit daran weiter zu arbeiten. Vielleicht findet sich auch  ein anderer Student, der bereit ist, sich in ein bestehendes Projekt einzuarbeiten und im Rahmen seiner Bachelorabeit daran weiterarbeiten möchte.



