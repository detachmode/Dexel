\chapter{Zusammenfassung}
\section{Ausblick}
Hier eine Auflistung dessen, was aus zeitlichen Gründen noch nicht realisiert
wurde, jedoch für den Einsatz in einem Projekt noch sehr wichtig wären.
Diese hat keinen Anspruch auf Vollständigkeit.
\subsubsection{Editor}
\begin{itemize}
	\item Joined-Inputs und auch Split Outputs. Dies erfordert Möglicherweise noch einmal
	eine kleine Überarbeitung des Domänenmodells. Auch die Darstellung wurde noch nicht realisiert. Zusätzlich wird die Generierung etwas komplexer und wirft weitere Fragen auf eine eindeutige Interpretation auf.
	
	\item Validierung der Syntax - Markierung invalider Syntax innerhalb des Editors wurden nicht realisiert (z.B. sind die Klammern richtig gesetzt).
	
	\item Search-Replace Funktionalität, um Datentypen oder andere Namen, die an vielen Stellen verwendet werden, schnell und  einfach umbenennen zu können.
	
	\item Mehr Möglichkeiten die Darstellung übersichtlicher zu gestalten: Auf und
	Zuklappen von Integrationen. Eine 'referenzierte' Kopie einer
	Funktionseinheit zu erstellen, um an anderer Stelle diese weiter zu
	verwenden.
	\item Saubere und eindeutige Darstellung einer Rekursion.
	\item Zuordnen von Funktionseinheiten zu Klassen.
	\item Möglichkeit mehrere Flow Design in einer Art Projekt zu Organisieren.
	Vielleicht auch in Form eines GUI-Skizzen-Editors, indem dann die
	Interaktionen eingetragen werden können.
	\item Autosave und Undo/Redo.
	\item Eine Möglichkeit große unüberschaubare Flow Designs in kleinere aufzuteilen und diese an anderen Stelle zu definieren.
	
\end{itemize}


\subsubsection{Generierung von Code}
\begin{itemize}
	\item Übergabe einer Eigenschaft eines Objektes an eine Funktionseinheit.
	Bsp: product.Price -> CalculateDicount -> ...				 
	\item Zusammenführen von Datenströmen (Joined Inputs), in manchen Fällen fördert dass die Leserlichkeit.
	\item Weitere Möglichkeiten einführen um die Daten auf den Datenflüssen kurz und leserlicher zu halten.
	Zum Beispiel indem man  Aliase für Typen definieren kann, sodass man statt \texttt{breiten:int*} auch einfach nur \texttt{breiten} schreiben kann. 
	\item Registrieren  von neuen bekannten Datentypen, sodass diese nicht als \enquote{missing Datatypes} angezeigt werden und auch nicht 
	generiert werden, falls man diese doch in Dexel definiert.
	Wenn zum Beispiel aus einer externen Bibliothek  Klassen benutzt werden.
	\item Erkennen von vorhandenen Methoden aus der Standardbibliothek/LINQ, sodass für diese keine neuen Methoden erzeugt werden.
	Auch hier müsste man dann eine Notation einführen, um ausdrücken zu können, dass eine Methode des Objekts aufgerufen werden soll und nicht einer Methode das Objekt übergeben werden soll.	
\end{itemize}


\section{Fazit}

\subsubsection{Flow Design}
Mir persönlich gefällt IOSP sehr gut. Nach einer Eingewöhnungszeit lernte ich die Lambda-Schreibweise lieben und finde sie nun auch sehr leserlich. Der Code der sonst in vielen Unterfunktionen versteckt ist, kann so an einer Stelle gehalten werden und trotzdem bleibt die Abstraktionsebene hoch. Ab einer gewissen Tiefe ist eine Aufteilung in unterschiedliche Methoden jedoch trotzdem sinnvoll.

Den Vorteil von entkoppelten Methoden lernte ich im Dexel Projekt kennen. Methoden können leichter angepasst werden und an unterschiedlichen Stellen verwendet werden. Die Aufgabe einer Operation ist klar definiert, was sie einfacher zu implementieren und besser testbar macht. 

Die Tatsache, dass dadurch die Integrationen frei von Kontrollstrukturen bleiben finde ich auch gut. 
Leider gilt die Aussage, das die Integrationen dadurch leicht zu verstehen bleiben, da sie frei von \enquote{Logik} bleiben leider nicht immer. Wenn eine Operation zwei oder mehrere Ausgänge hat und diese in der Integration \enquote{verdrahtet} werden, so landet doch eine gute Portion Logik auch in der Integration und dadurch wird diese auch schwerer zu verstehen. 
Trotzdem würde ich weiter diese Art bevorzugen. Falls es mal nicht so sein sollte, steht es einem schließlich auch frei an jenen Stellen von der Regel abzuweichen.


Leider habe bei der Umsetzung von IOSP innerhalb von Dexel so gut wie nie auf eine Flow Design Diagramm zurückgegriffen, stattdessen habe ich es innerhalb der IDE \enquote{herunterprogrammiert} und anschließend refaktorisiert. Das mag vor allem daran liegen, dass mir eine IDE durch Intellisense oft viel Arbeit erspart, gerade wenn bereits eine große Codebasis vorhanden ist.
Mit Intellisense kann ich bereits vorhandene Methoden auffinden und bekomme angezeigt, welche Parameter diese erwarten.
Auch die Eigenschaften eines Objektes werden mir übersichtlich angezeigt.
All das habe ich auf dem Papier ( oder auch im aktuellen Stand von Dexel nicht).



\subsubsection{Dexel}

Wie bereits erwähnt, habe ich beim Programmieren von Dexelnoch nicht so oft das Bedürfnis verspürt eine Flow Design Diagramm zu erstellen, wodurch ich die Sinnhaftigkeit eines Editors in Frage stellte.
Auch eine automatische Generierung  vollständig und ohne Fehler zu implementieren ist ein aufwendiges Unterfangen. Verglichen dazu ist der gewonnene Zeitaufwand  relativ gering. Die paar Zeilen der Integration kann man auch selbst relativ schnell herunter tippen, letzte Anpassungen vornehmen und dabei  auch LINQ  verwenden, um  auch komplexe Algorithmen runter zu schreiben.

 Es bedarf vielleicht erst einen perfekten Roundtrip, um eine automatische Generierung zu rechtfertigen und sinnvoll in einem Workflow mit einbinden zu können.
 
 Die Generierung könnte alternativ natürlich auf für Schulungszwecken verwendet werden, um Studenten/Entwicklern IOSP näher zu bringen.
 
Ein Entwurf auf dem Papier hat immer noch einen Einfachheit, die in Dexel noch nicht erreicht wurden.
Das mag vor allem daran liegen, dass noch nicht alle Notation im Editor umsetzbar sind (Joined Inputs). 
Auch einfach Pfeile von A nach B zu zeichnen, ohne auf eine für den Computer eindeutige Interpretation zu achten, hat seine Vorteile.

Dexel hat jedoch auch einige Vorteile gegenüber dem Entwurf auf dem Papier. Der erste ist Geschwindigkeit. 
Namen können auf der Tastatur schneller geschrieben werden, als auf mit dem Stift. Mit Hilfe von Tastenkürzel lassen sich schnell neue Funktionseinheiten hinten anhängen und so den Datenfluss schnell herunter schreiben.

Einfaches Duplizieren des Schaubildes und vorhandene Elemente neu anzuordnen und Texte abzuändern ist ein klarer Pluspunkt für Dexel.

Auch eine Validierung des Datenflusses kann vorteilhaft sein.



Der aktuelle Stand ist denke ich trotzdem ein guter Start geworden, der eine Vision aufzeigt, wie ein Editor für Flow Design aussehen könnte.
Mir persönlich fällt es schwer anhand des aktuellen Stands des Projektes abzuschätzen, ob ein vollausgereifter Editor nicht doch einen  Platz finden könnte im \enquote{Werkzeugkasten} eines Softwareentwicklers.
 Es würde trotzdem noch einige Monate an in Anspruch nehmen,  um auf einen Stand zu kommen mit dem man sinnvoll arbeiten kann und erst dann lässt sich sagen, wie sinnvoll er im Einsatz eines Softwareprojektes wirklich ist.
  Vielleicht ergibt es sich die Möglichkeit im Rahmen einer Masterarbeit daran weiter zu arbeiten. Vielleicht findet sich auch ein anderer Student, der bereit ist, sich in ein bestehendes Projekt einzuarbeiten und im Rahmen seiner Bachelorabeit daran weiterarbeiten möchte.



