


\chapter{Realisierung }

	\begin{figure}[H]
		\centering
		\includegraphics[width=1\linewidth]{./img/Dexel.png} 
		\caption{Dexel}
	\end{figure}



In diesem Kapitel soll vorgestellt werden, was in dem Zeitraum dieser
Bachelorarbeit erreicht wurde. Die Architektur der Anwendung wurde selbst nach
Flow Design umgesetzt und bietet somit dem Leser eine Quelle an weiteren
konkreten Beispielen aus der Praxis, wie eine Methode nach IOSP in der Praxis aussieht.

Als Arbeitstitel für die Anwendung wurde der Name Dexel gewählt.

\section{Übersicht über die unterschiedlichen Projekte}

Die Anwendung besteht aus einer \textit{Solution}, die folgende Unterprojekte beinhaltet \footnote{Bei komplexen Funktionalitäten wurde nach TDD (Test Driven Development)
programmiert, bei dem zuerst der Test geschrieben wird, der das zu erwartende
Ergebnis definiert, und erst anschließend die Methode implementiert wird.
. Diese Tests wurden in einem extra Test-Projekt für jedes Projekt zusammengefasst.}:

\subsubsection{Dexel.Model / Dexel.Model.Tests}

Dieses Projekt beinhaltet das Domänenmodell - alle Datentypen die zur internen Repräsentation
eines Flow Design Diagramms nötig sind. Außerdem beinhaltet dieses Projekt
statische Manager-Klassen, die das Arbeiten mit den Datentypen vereinfachen.

\subsubsection{Dexel.Editor / Dexel.Editor.Tests}

Dies ist das Hauptprojekt, das alle anderen Projekte integriert.
Nach Flow Design kann man IOSP auf Projekt-Ebene anwenden, hier wurde jedoch das IOSP
Prinzip nicht eingehalten. Dieses Projekt hat nicht nur die Aufgabe die
anderen Projekte zu integrieren, sondern beinhaltet selbst den
UI-Sourcecode. Diese Entscheidung wurde gefällt, da ein Extrahieren der UI
in ein anderes Projekt sich als zu schwierig erwies. Eine Lösung dafür zu
finden, wie ein Event aus dem UI mit einer Funktionalität verbunden werden
könnte, dass sich in einem Projekt befindet, war zeitlich zu
aufwendig. Aus diesem Grund wurde entschieden auf die zusätzliche
Komplexität einer Entkoppelung zu verzichten und es einfacher zu halten, indem
dieses Projekt sowohl die UI beinhaltet, als auch alle anderen Projekte
kennt.

\subsubsection{Roslyn / Rosyln.Tests}

Diese Projekt beinhaltet die Logik zur Erstellung von C\#-Code aus einem Flow
Design. Mircosoft Rosyln ist die Technik, die hier zum Erstellen von Code zum
Einsatz kommt.
Das Flow Design Diagramm muss in Form eines MainModels aus dem
Dexel.Model Projekt vorliegen. Aus diesem Grund gibt es eine Abhängigkeit
zwischen diesem Projekt und dem Dexel.Model Projekt. 

Eine Trennung dieser Abhängigkeit wurde versucht umzusetzen indem gegen ein Interface
programmiert wurde, anstatt gegen die konkrete Implementation in
Dexel.Model. Diese Interfaces der Datentypen und Manager-Klassen wurde dann
in ein Contracts-Projekt ausgelagert, von dem alle anderen Projekte abhängig
sein durften. Die zusätzliche Komplexität, Mehraufwand und ein Problem bei
der Serialisierung von Datentypen, die Interfaces als Eigenschaften besaßen,
machte es nicht wert hier eine Entkoppelung zu schaffen. Somit wurde der
Beschluss gefällt auf die Interfaces zu verzichten.

\subsubsection{Dexel.Library}

Dieses Projekt beinhaltet einige Methoden ( meist Extension-Methoden), die ein Arbeiten
nach Flow Design erleichtern. Diese wurden in ein separates Projekt
ausgelagert, damit alle anderen Projekte darauf zugreifen können.

\section{Das Domänenmodell}

Um nachfolgende Kapitel der Realisierung und die darin enthaltenden
Codeausschnitte verstehen zu können, braucht es ein Verständnis darüber, wie die
grundlegenden Datentypen des Domänenmodells aufgebaut sind. Um die Funktionalität der
jeweiligen Datentypen besser zu veranschaulichen, werden in diesem Kapitel
Bilder verwendet, welche die spätere Darstellung des Datentypen in der UI zeigen.

\subsubsection{MainModel}

Das MainModel ist, wie der Name schon sagt, das Haupt-Modell, das alle
anderen Modelle per Komposition beinhaltet. Somit kann einer Methode einfach eine Objektinstanz
eines MainModels übergeben werden und erhält dadurch alle Informationen über das aktuelle Flow Design Diagramm. 
Das \textit{MainModel} beinhaltet alle Funktionseinheiten, alle verbindende
Datenströme (\textit{Connections}) und alle benutzerdefinierten Datentypen (\textit{DataTypes}).

\begin{lstlisting}[caption=MainModel Klasse]
[ImplementPropertyChanged]
public class MainModel
{
	public List<FunctionUnit> FunctionUnits { get; set; }
	public List<DataStream> Connections { get;  set; }
	public List<CustomDataType> DataTypes { get; set; } 
}
\end{lstlisting}

\subsubsection{FunctionUnit}


\begin{lstlisting}[caption=FunctionUnit Klasse]
[ImplementPropertyChanged]
public class FunctionUnit
{
	public Guid ID { get; set; }
	public string Name { get; set; }
	public Point Position { get; set; }
	public List<FunctionUnit> IsIntegrating { get; set; }
	public List<DataStreamDefinition> InputStreams { get; set; }
	public List<DataStreamDefinition> OutputStreams { get; set; }
}
\end{lstlisting}

	
	\begin{figure}[H]
		\centering
		\includegraphics[width=0.9\linewidth]{./img/FunctionUnitView.png} 
		\caption{Dexel-Screenshot: FunctionUnit-View}
	\end{figure}

Der Name ist der Name der Funktionseinheit ( der Text, der bei der
Darstellung später innerhalb des Kreises erscheint). Dieser wird später per \textit{Binding}
direkt an die UI gebunden. Aus diesem Grund implementiert dieses Klasse,
genau wie alle anderen des Modells, die ImplementPropertyChanged
Funktionalität. Diese bewirkt, dass bei einer Änderung im UI automatisch das
entsprechende Eigenschaft im Modell aktualisiert wird und umgekehrt.

Die Position beschreibt die Position der Funktionseinheiten innerhalb des
Diagramms.  

Das IsIntegrating-Eigenschaft gibt an, ob diese Funktionseinheit eine Integration
ist und welche andere Instanzen von Funktionseinheiten sie integriert.
Eine leere Liste besagt, dass die Funktionseinheit keine Integration ist.

Die Input- und OutputStreams definieren die möglichen ein- und ausgehenden
Datenströme der Funktionseinheiten. An diese DataStreamDefinitionen können sich DataStreams
verbinden. Dadurch lassen sie die Datenflüsse modellieren.


	\subsubsection{DataStreamDefinition}
	
	\begin{lstlisting}[caption=DataStreamDefinition Klasse]
[ImplementPropertyChanged]
public class DataStreamDefinition
{
	public Guid ID { get;  set; }
	public string DataNames { get;  set; }
	public string ActionName { get;  set; }
	public FunctionUnit Parent { get;  set; }
	public bool Connected { get;  set; }
}
	\end{lstlisting}
	
		
		\begin{figure}[H]
			\centering
			\includegraphics[width=0.6\linewidth]{./img/DataStreamDefinitionView.png} 
			\caption{Dexel-Screenshot: DataStreamDefinition-View}
		\end{figure}
	
	Eine Funktionseinheit verfügt über ein oder mehrere ein- und ausgehende
	DataStreamDefinitionen. Diese können verbunden sein oder nicht. Wenn eine
	Verbindung erstellt und gelöscht wird, muss deshalb auch die Connected-Eigenschaft
	immer angepasst werden, damit das Modell valide bleibt.
	Ob eine DataStreamDefinition verbunden ist, oder nicht, ist später
	für die Darstellung relevant.
	Eine DataStreamDefinition kennt auch die Funktionseinheit, von der sie ein
	Ein- oder Ausgang ist.
	
	Eine weitere grundlegende Eigenschaft ist die Benennung der Daten, die auf dem
  Datenfluss fließen. Für Ausgänge ist auch die Angabe eines
	ActionNames manchmal nötig. Dieser soll später unterhalb des Pfeiles
	dargestellt werden.

\subsubsection{DataStream (Connections)}

Um Datenflüsse zwischen Funktionseinheiten zu beschreiben, bedarf es einer
Verbindungsklasse. Die DataStream-Klasse stellt diese Verbindungsklasse dar.


\begin{lstlisting}[caption=DataStream]
[ImplementPropertyChanged]
public class DataStream
{
	public Guid ID { get; set; }
	public string DataNames { get;  set; }
	public List<DataStreamDefinition> Sources { get;  set; }
	public List<DataStreamDefinition> Destinations { get;  set; }

}
\end{lstlisting}

		\begin{figure}[H]
			\centering
			\includegraphics[width=0.9\linewidth]{./img/DataStreamView.png} 
			\caption{Dexel-Screenshot: DataStream-View}
		\end{figure}


Ein DataStream hat ein oder mehrere Referenzen an DataStreamDefinition als
Quellen und ein oder mehrere Referenzen an DataStreamDefinition als Ziele.
Um ein Datenstrom zu beschreiben, der aus mehren Quellen Daten bezieht und
an einer Stelle zusammenläuft, wird ein DataStream benötigt, der mehrere
Einträge in der Source-Liste besitzt und ein Eintrag in der
Destination-Liste. Diese Datenstrom wäre dann ein Joined Input.
Ein Datenstrom mit einer Quelle und mehreren Zielen wäre ein s.g. Split.

Die DataNames Eigenschaft beinhaltet den Text, der später in der Mitte des
Pfeiles dargestellt werden soll. Eine Änderung dieser Eigenschaft bedarf
einer Aktualisierung der DataNames aller Sources und Destinations.
Die Aktualisierungsmethode muss die optionalen Pipe-Notation kennen und
entsprechend dieser die Ein und Ausgänge aktualisieren.

Der aktuelle Stand der UI kann nur Datenflüsse mit einer Quelle und
einem Ziel darstellen.

\subsubsection{DataType}

\begin{lstlisting}[caption= CustomDataType und SubDataType Klasse]
[ImplementPropertyChanged]
public class CustomDataType
{
	public string Name { get; set; }
	public List<SubDataType> SubDataTypes { get; set; }
}

[ImplementPropertyChanged]
public class SubDataType
{
	public string Name { get; set; }
	public string Type { get; set; }
}
\end{lstlisting}


\begin{figure}[H]
	\centering
	\includegraphics[width=0.5\linewidth]{./img/CustomDataType.png} 
	\caption{Dexel-Screenshot: CustomDataType-View}
\end{figure}


Ein benutzerdefinierter Datentyp besteht aus einem Namen und einer Liste von mehreren
\texttt{SubDataType}-Objekten. 

Ein SubDataType besteht aus einem Namen und den Namen
des Typen (zum Beispiel string, int oder auch ein anderen benutzerdefinierten
Datentyp).

\subsubsection{Manager-Klassen}

\begin{enumerate}
	\item MainModelManager
	
	Einer der relevantesten Manager-Klassen ist die MainModelManager-Klasse,
	diese stellt die wichtigsten Funktionalitäten zur Verfügung die mit dem
	Arbeiten des MainModels gebraucht werden. Einige dieser Funktionalitäten
	wären: Verbinden und Trennen von Funktionseinheiten, vorwärts und rückwärts
	Traversieren entlang des Graphen, Hinzufügen und Entfernen einer
	Funktionseinheit von einer Integration, Hinzufügen, Löschen und Duplizieren
	von Funktionseinheiten, oder Teile des Graphen.
	
	\item DataStreamManager
	
	Diese statische Klasse bietet einige Funktionalitäten, die das Arbeiten mit
	Objekten der DataStream-Klasse vereinfachen soll.
	
	Ein Beispiel hierfür wäre das Ändern der DataNames-Eigenschaft eines DataStreams. 
	Wie bereits im letzten Abschnitt erwähnt, muss beim Ändern der Daten
	eines Datenflusses auch die Daten seiner Sources und Destinations
	angepasst werden. 
	
	Um dies nochmal zu verdeutlichen, zwei konkrete Beispiele:
	Falls der Datenfluss auf \textbf{(int) | (string) } geändert wurde
	, so muss die DataNames-Eigenschaft der Source-DataStreamDefinition auf
  \textbf{(int)} gesetzt werden und die der
	Destination-DataStreamDefinition auf \textbf{(string)}. 
	Falls der Datenfluss auf \textbf{(double)} geändert wurde, so müssen Source-
	und Destination-Daten auf  \textbf{(double)} gesetzt werden.\footnote{	Da aktuell nur DataStreams mit einer Source und einer Destination im Editor unterstützt
		
		werden, wurde aktuell auch nur dieses Szenario implementiert. Ändert sich
		diese Einschränkung müsste man sich Gedanken darüber machen, was in diesen
		Fällen zu tun wäre. Ein Option wäre, die Pipe-Notation in diesen Fällen zu
		verbieten. Die UI würde die Daten der DataStreamDefinitionen direkt
		anzeigen und der Benutzer würde diese dann direkt ändern. Der Datenstrom
		selbst würde dann kein eigenes Textfeld besitzen und die DataNames-Eigenschaft hätte in diesen Fall keine Bedeutung. 
		Vielleicht wäre es dann auch besser im Modell separate Klassen
		anzulegen für Split Outputs und Joined Input. Dadurch hätte die
		einfache DataStream-Klasse dann anstatt einer Liste von DatastreamDefinitionen nur noch ein einfaches Feld
		für eine Source-DataStreamDefinition und eine Destionation-DataStreamDefinition.}
	
	\begin{lstlisting}[caption=ChangeDatanames Methode]
public static void ChangeDatanames(DataStream datastream, string newDatanames)
{
	// update datanames of connection itself
	datastream.DataNames = newDatanames;
	
	// update datanames of DSDs
	TrySolveWithPipeNotation(newDatanames,
		onSuccess: (outputPart, inputPart) =>
		{
			datastream.Sources.First().DataNames = outputPart;
			datastream.Destinations.First().DataNames = inputPart;
		},
		onNoSuccess: () =>
		{
			datastream.Sources.First().DataNames = newDatanames.Trim();
			datastream.Destinations.First().DataNames = newDatanames.Trim();
		});
}
\end{lstlisting}
	
\end{enumerate}



\section{Der Editor}

\subsection{Vorstellung was erreicht wurde}

Die Grundlegenden Basisfunktionen aus dem Anforderungs-Kaptitel wurden größtenteils implementiert. Hierbei kam WPF als GUI-Framework zum Einsatz.
Im folgendem einige Bilder und Beschreibungen der GUI und Interaktionen.


\subsubsection{Erstellen von Funktionseinheiten, Verschieben, Benennen, Selektieren}

	Das DrawingBoard wurde implementiert, auf dem der Benutzer über 
	Rechtsklick->Create New Function Unit eine erste Funktionseinheit erzeugen
	kann. Per Drag\&Drop kann er diese dann innerhalb des DrawingBoards frei
	verschieben. Mit einer Rectangle-Selection ist es mögliche mehrere
	Funktionseinheiten zu selektieren. Selektierte Funktionseinheiten können
	gemeinsam verschoben, dupliziert und gelöscht werden.
	
	Nach dem Erstellen einer neuen Funktionseinheit, wird diese automatisch
	selektiert und der Tastaturfokus wird in das Textfeld des Kreises gesetzt.
	Dadurch lässt sich diese Benennen.
	
	Beim Klicken auf den äußeren Teil des Kreises wird die Funktionseinheit
	selektiert. Beim Klicken auf das Textfeld, wechselt der Tastaturfokus auf
	das Textfeld ( ein Mouseover zeigt auch an, über welchen Teil des Kreises
	die Maus sich gerade befindet, auch ein Klicken und Ziehen um sofort ein Teil
	des Textes zu markieren bleibt damit dem Benutzer weiterhin möglich, so wie er es von
	einem Textfeld gewohnt ist).
	
	
\subsubsection{Erstellen/Löschen/Manipulieren von Inputs und Outputs}

	Eine Funktionseinheit wird standardmäßig mit einem Eingang und einem Ausgang
	erstellt. Die Daten die aus diesen hinein- oder herausfließen können auf
	dem Textfeld eingetragen werden. Dabei bietet diese Textfeld ein einfaches
	Syntaxhighlighting, dass mit Doppelpunkt getrennte Namen-Type-Paare
	farblich trennt. Auch Symbole wie * | [] () , \ldots{} haben eine eigene Farbe.
	
	Der Action-Name kann unterhalb des Pfeiles eingetragen werden.
	
	Eine Funktionseinheit kann mehr als nur einen Ausgang besitzen.
	Das Hinzufügen eines neuen Ausgangs ist über Rechtsklick -> Add New Output möglich.
	Das Löschen eines Ausgangs ist ebenso möglich.

	Die Reihenfolge bei mehreren Ausgängen kann per Drag\&Drop verändert werden.
	
\subsubsection{Verknüpfen und Trennen von Funktionseinheiten über Drag\&Drop }

	Wird das Ende eines Pfeiles eines Ausgangs auf eine andere Funktionseinheit gedropt, so werden beide
	miteinander Verbunden. Die Datennamen des Flusses werden bei nicht
	Übereinstimmung dieser mit Hilfe der Pipe-Notation in das Textfeld des nun neu
   erzeugten Datenstromes eingetragen. Stimmen beide überein, wird auf die Pipe-Notation
	verzichtete.
	
	Werden die Daten eines verbundenen Datenflusses geändert, werden die Eingänge
	und Ausgänge mit Berücksichtigung auf die Pipe-Notation angepasst, sodass
	beim Trennen der beiden Funktionseinheiten, die Änderungen erhalten bleiben.
	
	Durch Drag and Drop eines verbunden Pfeiles auf eine leere Stelle des
	DrawingBoard kann eine Verbindung getrennt werden. Wird sie auf eine
	andere Funktionseinheit gedropt, so wird diese als neues Ziel gesetzt und die 
	Verbindung zur vorherigen Funktionseinheit gelöscht. 
	
\subsubsection{Erstellen von Integrationen}

	Durch Rechtsklick auf eine Funktionseinheit kann im Kontextmenü der Eintrag
	'Make to Integration of (Pick)' ausgewählt werden. Der Cursor verändert
	sich und wird nun eine andere Funktionseinheit angeklickt, so wird der
	komplette Flow, von der diese Funktionseinheit Teil ist, zu einem
	Sub-Flow der Integration gemacht.
	
	Das Entfernen eines Flows von einer Integration ist auch über das Kontextmenü
  möglich.
  Dabei wird der komplette zusammenhängende Flow aus der
	Integration entfernt. 
	
	
	Bei einer Modifikation des Datenflusses innerhalb einer Integration, werden nach
	bestimmten Regeln die nachfolgenden (abgetrennten) Funktionseinheiten
	ebenfalls aus der Integration entfernt. Wird die erste Funktionseinheit
	entfernt, gilt diese Regel nicht.
	
	\subsubsection{Definieren von Datentypen}

	Eigene Datentypen können auf der rechten Seite des Editors angelegt werden.
	Durch Rechtsklick -> Add New DataType. Außerdem zeigt der obere Button an,
	ob im aktuellen Diagramm Datenflüsse mit Daten fließen, die nicht definiert
	sind. ( int, string, double, usw. werden automatisch ignoriert). Ein Klick
	auf diesen erstellt für jeden nicht-definierten Datentyp einen neuen Eintrag.
	Auch Datentypen innerhalb eines eigenen Datentypen werden überprüft, ob sie 
	bekannt sind oder nicht. Bsp. 
	Person 
	name:string
	address:Address  
	
	Der Editor würde überprüfen ob für Address ein Datentyp definiert wurde oder nicht.
	
\subsubsection{Navigation und Tastenkürzel}

	Zur Navigation innerhalb des DrawingBoards wird das Mausrad verwendet.
	Durch Scrollen wird in das DrawingBoard herein und heraus gezoomt.
	Durch gedrückt halten des Mausrades (mittlere Maustaste) und Bewegen der
	Maus kann die Ansicht verschoben werden ( das DrawingBoard ist endlos groß)
	
	Ein weiteres Feature besteht darin, dass ab bestimmten Zoom-Stufen die
	Schriftgrößen der Namen der Funktionseinheiten angepasst werden und die 
	Textfelder der Datenflüsse ausgeblendet werden.
	Außerdem können Textfelder nicht mehr fokussiert werden, was ein einfacheres
	Verschieben der Funktionseinheiten ermöglichen soll. Diese Gegebenheit wird
	visuell kenntlich gemacht, indem die Hintergrundfarbe des Textfeldes bei
	einer selektierten Funktionseinheit mit der Selektierungsfarbe übereinstimmt.
	Auch der Mauszeiger zeigt bei einem Mouseover an, dass nun nicht mehr in
	das Textfeld geklickt werden kann.
	
	
	\subsubsection{Weitere Features}

	\begin{itemize}
		\item Speichern, Laden, Mergen
		
		Das Speichern und Laden in 3 Dateiformate wird unterstützt
		(yaml, json und xml - nach Dateigröße aufsteigend sortiert).
		Auch das Laden eines anderen Flow Designs in das aktuelle geladene wird 
		mit der Merge-Funktion unterstützt.

		\item Unhandled Exception Error Dialog
		
		Wird eine Exception geworfen, die nicht behandelt wurde, so wird eine
		allgemeine Fehlerbehandlung aufgerufen. Das Programm stürzt somit nicht ab,
		sondern ein Dialog erscheint, mit einem Stacktrace und Informationen
		über die geflogenen Exception. Der Benutzer kann das entscheiden, ob er
		hier das Programm Beenden will, oder weiter den Fehler ignorieren will.
		Der Stacktrace kann gegenenfalls kopiert und an den Entwickler als
		Bugreport zugeschickt werden.
		
		\item Help-Window
		
		Ein einfaches Hilfefenster, dass dem Benutzer einen Überblick über die
		vorhandenen Tastenkürzel zeigt und die Navigation mit der Maus erklärt.
	\end{itemize}
	



\subsection{Views / ViewModels}

Das Projekt wurde nicht strikt nach MVVM-Regeln (Model-View-ViewModel) 
umgesetzt, jedoch bedient es sich der Idee, das es eine View gibt, die
als Datenkontext ein ViewModel zugewiesen bekommen hat. Durch das Zuweisen eines
Datenkontextes wird es GUI-Elementen der View ermöglicht sich an Eigenschaften des ViewModels zu
binden. Ein Bindung bewirkt, dass sich das GUI-Element automatisch aktualisiert,
sobald sich die dazugehörige Eigenschaft ändert. Eine Änderung einer
Eigenschaft des ViewModels ändert somit automatisch die View.

Die GUI besteht aus mehreren Views (xaml-Dateien) und dazugehörigen ViewModels.
Die Aufgabe des ViewModels besteht vor allem darin, ein Domänenmodell entgegenzunehmen und dieses
darzustellen, bzw. die aktuelle Darstellung zu aktualisieren.

Nach jeder Änderung am Domänenmodell - zum Beispiel das Hinzufügen einer neuen
Funktionseinheit -  dieses komplett neu zu laden (Löschen und neu Hinzufügen aller
ViewModels, die wiederum ein Neugenerieren der UI-Framework-Elemente zur
Folge hatte) erwies sich als nicht sehr performant. 
Ab Diagrammen, mit über 20 Nodes, stieg die Zeit zur Aktualisierung der View
bereits auf mehrere Sekunden an.
Die Lösung bestand darin, nicht einfach alles zu Löschen und neu
hinzuzufügen, sondern darin, die Änderungen am Modell zu lokalisieren und nur
diese neu zu erstellen, bzw. nur die Eigenschaften neu zu setzen. Durch
diese Verbesserungen wurde die Performance deutlich gesteigert, sodass
Diagramme mit mehreren hundert Funktionseinheiten keine spürbaren Perfomanceverluste mit
sich führen. Einzig das Duplizieren von vielen Funktionseinheiten dauert nach wie vor
etwas länger. 

\subsection{Interaktionen}

Wie bereits im Grundlagen-Teil erwähnt, (Abschnitt Entwurfsmethode) schlägt Flow Design
vor, alle Events als Interaktionen zu bezeichnen und für jedes dieser
Änderungen ein eigenen Flow Design zu erstellen. 
Es bietet sich somit an, alle Interaktionen in einer Klasse zu sammeln.
Diese bietet somit einen Überblick über alle Funktionalitäten der GUI.
Da diese Integrationen sind, sind sie leicht zu verstehen (mit Ausnahmen). Die
Interaktionen rufen Methoden von anderen Klassen auf, die die Operationen am
Mainmodel vereinfachen. Am Ende fast jeder Interaktion wird die \texttt{ViewRedraw}
Methode aufgerufen, die das \texttt{MainViewModel} veranlasst, das Model neu zu
laden und somit die Änderungen der Interaktion in der GUI sichtbar macht.
Aus diesem Grund erwies es sich als schlecht, wenn eine Interaktion eine andere
Interaktion aufruft, um ihre Funktionalität umzusetzen. 
Stattdessen war es eine bessere Lösung, den Code der einen Interaktion in
die andere zu Kopieren. Dies widerspricht zwar dem DRY Prinzip, jedoch eine
Coderedundanz innerhalb von Integrationen stellt sich als nicht sehr schlimm
heraus. Integrationen beinhalten schließlich keine Logik \footnote{Beim
Aufruf einer Funktionseinheit, die mehrere Outputs liefert, existiert
eigentlich doch Logik in der Integration ( Bsp: IsIntegration: Wenn ja,
dann X wenn nicht, dann Y). Dadurch verlieren Integrationen etwas an ihrer
Leichtgewichtigkeit und sind nicht mehr ganz so einfach zu verstehen} und haben eine hohe
Abstraktion.

Beispiel dieser Aussage:
\begin{lstlisting}[caption=AppendNewFunctionUnit]
public static object AppendNewFunctionUnit(FunctionUnit currentFunctionUnit, double offsetX, DataStreamDefinition outputToConnect, MainModel mainModel)
{
	var newFunctionUnit = FunctionUnitManager.CreateNew();
	
	newFunctionUnit.Position = currentFunctionUnit.Position;
	newFunctionUnit.MoveX(offsetX);
	
	// default IO of new function unit: input of new function unit = output to connect to of current function unit
	newFunctionUnit.InputStreams.Add(
		DataStreamManager.NewDefinition(newFunctionUnit, outputToConnect));
	newFunctionUnit.OutputStreams.Add(
		DataStreamManager.NewDefinition(newFunctionUnit, "()"));
	MainModelManager.ConnectTwoDefintions(outputToConnect, newFunctionUnit.InputStreams.First(), mainModel);
	
	mainModel.FunctionUnits.Add(newFunctionUnit);
	
	ViewRedraw();
	
	return newFunctionUnit;
}
\end{lstlisting}

\begin{lstlisting}[caption=CreateNewOrGetFirstIntegrated]
public static FunctionUnit CreateNewOrGetFirstIntegrated(FunctionUnit currentFunctionUnit, MainModel mainModel)
{
	FunctionUnit @return = null;
	
	currentFunctionUnit.IsIntegration(
		isIntegration: () => @return = 		currentFunctionUnit.IsIntegrating.First(),
		isNotIntegration: () =>
		{
			var newFunctionUnit = FunctionUnitManager.CreateNew();
			newFunctionUnit.Position = currentFunctionUnit.Position;
			newFunctionUnit.MoveY(100);
			
			newFunctionUnit.InputStreams.Add(
			DataStreamManager.NewDefinition(newFunctionUnit, currentFunctionUnit.InputStreams.First()));
			newFunctionUnit.OutputStreams.Add(
			DataStreamManager.NewDefinition(newFunctionUnit, "()"));
			
			currentFunctionUnit.IsIntegrating.Add(newFunctionUnit);
			
			mainModel.FunctionUnits.Add(newFunctionUnit);
			
			@return = newFunctionUnit;
			ViewRedraw();
		});
	
	return @return;
}
	\end{lstlisting}





	Die \texttt{AppendNewCell} Methode erzeugt eine neue Funktionseinheit und 
	verschiebt diese entlang der X-Postion.
	Außerdem setzt sie den Input gleich der DataStreamDefinition die
	übergebenen wurde und verbindet diese beide.
	\texttt{AppendNewCell} wird durch die Tastenkombination Ctrl-Tab ausgelöst, wenn
	sich der Tastaturfokus innerhalb eines Textfeldes einer View einer Funktionseinheit oder
	DatastreamDefinition befindet. Bei ersterem wird der erste unverbundene
  Ausgang als die	DataStreamDefinition genommen, an dem die neue Funktionseinheit angehängt wird \footnote{nicht Teil der gezeigten Methode} .
	
	Beide Methoden geben eine
	Domänenmodell-Instanz als \texttt{object} an die GUI zurück. Die GUI-Logik findet dann die
	dazugehörige View und setzt den Fokus auf diese.
	
	Beide Methoden sind Methoden aus der Interaktions-Klasse, sind werden also
	direkt aus einem Event von der GUI ausgelöst. 
	Beide Methoden haben ähnliche Methodenaufrufe ( Neue Funktionseinheit
	erzeugen, sie auf die gleiche Position zu setzten wie die der übergebenen
	Funktionseinheit, neue Standardwerte für den Output-Stream der neuen
	Funktionseinheit setzen, dem MainModel die neue Funktionseinheit hinzufügen
  und die Ansicht neu zu zeichnen).
  Diese könnten in eine neue Integration ausgelagert werden, hätte jedoch eine unnötige
	Verschachtlung von Code als Auswirkung. Besser ist es hier die
	Coderedundanzen nicht als Code-Smell zu sehen und diese zu belassen.
	So ist auf einen Blick ersichtlich, was die Interaktion genau macht, ohne
	im Code herum springen zu müssen.

\subsection{Eigene Tabstopp-Logik}

Mit Tab und Shift-Tab soll es dem Nutzer möglich sein den Tastaturfokus zu
verändern\footnote{Dieses Beispiel zeigt dabei noch einmal, das Coderedundanzen innerhalb
von mehreren Integrationen nichts Schlechtes sein muss.
Außerdem macht es auch deutlich, wie eine etwas komplexerer Integration mit
mehreren verschachtelten Lambda-Ausdrücken in der Praxis aussehen kann. Auch das Arbeiten mit dem Domänenmodell und den Managerklassen soll dem Leser hier noch einmal verdeutlicht werden.}.



Der nächsten Tabstopp soll nach folgenden Regeln und abhängig vom aktuell
fokussierten \textit{Model} bestimmt werden:

\begin{enumerate}
	\item FunctionUnit

	Besitzt aktuell die View einer FunctionUnit den Tastaturfokus, so soll als
	nächster Tabstopp der erste Datenfluss, der verbunden ist gewählt werden. Ist keiner
	verbunden, wähle als nächsten Tabstop den ersten Ausgang der Funktionseinheit.
	
	\begin{figure}[H]
		\centering
		\includegraphics[width=0.6\linewidth]{./img/tabstop_functionunit.png}
		\caption{Aufgabe - Tabstopp von FunctionUnit aus}
	\end{figure}
	
	\item DataStream

	 Wenn der Fokus aktuell auf einem DataStream liegt, so ist der nächste Tabstopp die Ziel-Funktionseinheit des Datenflusses.

	\begin{figure}[H]
		\centering
		\includegraphics[width=0.6\linewidth]{./img/tabstop_datastream.png}
		\caption{Aufgabe - Tabstopp von DataStream aus}
	\end{figure}
	
	\item DataStreamDefinition

	Der komplexeste Fall: 
	Zu erst muss überprüft werden, ob es sich um ein Eingang oder Ausgang
	handelt. Ist es ein Eingang (A), so soll als nächster Tabstopp die Funktionseinheit
	zurückgegeben werden, von der die DataStreamDefinition der Eingang ist. 
	Bei einem Output muss überprüft werden, ob das Ende des Flows erreicht
	wurde, oder nicht. Wird ein verbundener Output entdeckt, wird der
	entsprechende DataStream als nächster Tabstopp zurückgegeben (B). Ist das Ende
	erreicht, so soll zum Anfang des kompletten Flows gesprungen werden (C).
	
	
	\begin{figure}[H]
		\centering
		\includegraphics[width=\linewidth]{./img/tabstop_datastreamdefiniton.png}
		\caption{Aufgabe - Tabstopp von DataStreamDefinition aus}
	\end{figure}
	
	\begin{lstlisting}[caption=Tabstopp vorwärts]
public static object TabStopGetNext(object focusedModel, MainModel mainModel)
{
	object @return = null;
	
	focusedModel.TryCast<FunctionUnit>(fu =>
	{
		// prefer connected outputs as next tabstop
		// if no connected take first output defintion if there are any
		fu.OutputStreams.GetFirstConnected(
			foundConnected: connectedDsd => 
				@return =MainModelManager.FindDataStream(
				connectedDsd, mainModel),
			noConnected: () => 
				@return = fu.OutputStreams.FirstOrDefault());
		});
		
		focusedModel.TryCast<DataStream>(stream =>
		{
			// if focus was inside datastream take its destination function unit as next tabstop
			if (stream.Destinations.Any())
				@return = stream.Destinations.First().Parent;
		});
		
		focusedModel.TryCast<DataStreamDefinition>(dsd =>
		{
			// if focus was inside definition there are two case:
			// is input definition: next tabstop is the function unit of the definition
			// is output definition: in case the end of the flow was reached ( no connected output ) 
			// the next tabstop is the first input definition of the beginning of the whole flow.
			// Is the end not reached go to first connected output datastream
			dsd.CheckIsInputOrOutput( 
				isInput: () => @return = dsd.Parent,
				isOutput: () =>
			{
				dsd.Parent.OutputStreams.GetFirstConnected(
					foundConnected: connectedInput => 
						@return = MainModelManager.FindDataStream(
						connectedInput, mainModel),
					noConnected: () =>
					 // loop tabstop focus when the 
					 // end is reached
						@return = MainModelManager.GetBeginningOfFlow(
							dsd.Parent, mainModel)); 
			});
	});
	return @return;
}

\end{lstlisting}
	Analog dazu die Tabstopp-Methode in die entgegengesetzte Richtung.
	
	
\begin{lstlisting}[caption=Tabstop rückwärts]
public static object TabStopGetPrevious(object focusedModel, MainModel mainModel)
{
	object @return = null;
	
	focusedModel.TryCast<FunctionUnit>(fu => 
	{
		fu.InputStreams.GetFirstConnected(
			foundConnected: connectedDsd => 
				@return = MainModelManager.FindDataStream(
				connectedDsd, mainModel),
		noConnected: () =>
			@return = fu.InputStreams.FirstOrDefault());
	});
	
	focusedModel.TryCast<DataStream>(stream => 
	{
		if (stream.Sources.Any())
			@return = stream.Sources.First().Parent;
	});
	
	focusedModel.TryCast<DataStreamDefinition>(dsd => 
	{
		dsd.CheckIsInputOrOutput(
			isOutput: () => @return = dsd.Parent,
			isInput: () => 
			{
				dsd.Parent.InputStreams.GetFirstConnected(
					foundConnected: connectedInput =>
						@return = MainModelManager.FindDataStream(
						connectedInput, mainModel),
					noConnected: () =>
						// loop tabstop focus when
						// the beginning is reached
						@return = MainModelManager.GetEndOfFlow(
						dsd.Parent, mainModel));
		});
	});	
	return @return;
}
\end{lstlisting}
	
	

	Auf oberster Ebene wird überprüft um welchen Typ von Objekt es sich
	handelt, der aktuell fokussiert ist \footnote{Teile davon war Aufgabe der UI und die
	Interaktion bekommt das Model dann als \texttt{object} übergeben. Deshalb bedarf es
	innerhalb der Methode einer Überprüfung des Typen mit TryCast. Natürlich
  könnte man dies auch durch ein Interface verhindern, dann würden die 3 Fälle
  jedoch nicht mehr klar vor einem liegen, sondern in den jeweiligen
  Implementierungen der Klassen versteckt.}. Nun existieren die drei Fälle, abhängig vom übergebenen Typen.\footnote{Zur Erinnerung: Die \texttt{Sources}-Eigenschaft eines \texttt{DataStream} beinhaltet nicht die Funktionseinheit,
	sondern die \texttt{DataStreamDefinition} einer Funktionseinheit. Die eigentliche
	Funktionseinheit enthält die \texttt{Parent}-Eigenschaft der \texttt{DataStreamDefinition}.
	Analog dazu enthält die \texttt{InputStream}- und \texttt{OutputStream}-Eigenschaft der
	Funktionseinheit auch nur die \texttt{DataStreamDefinition}-Objekte nicht ein \texttt{DataStream}-Objekt.
	Eine \texttt{DataStreamDefinition} kennt jedoch nicht den Datenfluss, mit dem sie
	verbunden ist. Eine Helfer-Methode der \texttt{MainModelManager}-Klasse stellt
	diese Funktionalität zum Auffinden des \texttt{DataStream} zur Verfügung.}
\end{enumerate}

\subsection{Validierung des Datenflusses - Farbliche Kennzeichnung }

Eine Instanz vom Typ ValidationException kann dem ViewModel übergeben werden.
Die ValidationException beinhaltet die Information, ob es sich um eine Fehler oder um eine Warnung handelt (Fehler wird rot markiert, Warnungen grün), welche Elemente den Fehler anzeigen sollen, sowie einen Fehlertext, der als Tooltip an dem Element angezeigt wird.

\begin{figure}[H]
	\centering
	\includegraphics[width=0.6\linewidth]{./img/DexelValidation.png}
	\caption{Dexel - Warnung- und Fehler-Darstellung}
\end{figure}



\section{Roslyn - Generierung von Code aus einem Diagramm}

Da eine Flow Design auf unterschiedlichen Weisen im Code umgesetzt werden
kann, mussten hier Entscheidungen getroffen werden, in welchen Fällen
welche Weise gewählt wird. Wird das Projekt fortgeführt, könnte man in
Betracht ziehen, dem Nutzer einige Optionen zur Konfiguration der Generierung
zur Verfügung zu stellen. Aktuell bietet das Programm nur die hier vorgestellte Weise zur Verfügung.


\subsection{Vorstellung - was erreicht wurde}

Um den aktuellen Stand der Code-Generierung zu präsentieren, werden nachfolgend zwei Beispiele 
vorgestellt.

\subsubsection{CSV Tabellieren -  Beispiel aus YouTube Video von Ralf Westphal und Stefan Lieser}

Die Aufgabe besteht darin, den Inhalt einer CSV-Datei in eine ACSII-Tabelle zu formatieren.
\footcite[S.12]{kata}
\begin{figure}[H]
	\centering
	\includegraphics[width=0.8\linewidth]{./img/csvAufgabe.png}
	\caption{Aufgabe - CSV Tabellieren}
\end{figure}


Das Flow Design, das Ralf Westphal und Stefan Lieser in dem Video entwerfen sieht folgendermaßen aus. \footnote{Video CSV Tabellarisieren \cite{youtubevideos}}


\begin{figure}[H]
	\centering
	\includegraphics[width=1\linewidth]{./img/youtubeflowdesign.png}
	\caption{CSV Tabellarisieren - Flow Design aus YouTube Video}
\end{figure}


Nun das Flow Design umgesetzt in Dexel. Zu beachten ist, das die Split Output und Joined Input Notation mit der Pipe-Notation ersetzt wurde, da Dexel aktuell keine Joined-Notation unterstützt.


\begin{figure}[H]
	\centering
	\includegraphics[width=0.4\linewidth]{./img/csvtabellierenDexelDataTypes.png}
	\caption{CSV Tabellarisieren - Datentypen}
\end{figure}




\begin{landscape}
\begin{figure}
	    \hspace*{-1.5cm}
	    \makebox[\linewidth]{
	    		\includegraphics[width=1.25\linewidth]{./img/csvtabellierenDexel.png}
	    }

	\caption{CSV Tabellarisieren - Dexel Flow Design}
\end{figure}
\end{landscape}






\begin{lstlisting} [caption = CSV tabellieren mit Dexel generierter Code]
// Integrationen
public static IEnumerable<string> CSVTabellieren( IEnumerable<string> strings)
{
	var records = CSVParsen(strings);
	var tbl = HeaderVomBodyTrennen(records);
	return TabelleBauen(tbl);
}

public static IEnumerable<string> TabelleBauen(Tabelle tbl)
{
	var breiten = SpaltenbreitenErmitteln(tbl);
	var header = HeaderFormattieren(breiten, tbl);
	var body = BodyFormattieren(breiten, tbl);
	return TabelleZusammensetzen(body, header);
}
\end{lstlisting}

\begin{lstlisting} [caption = CSV tabellieren mit Dexel generierter Code]
// Datentypen
public class Tabelle
{
	public Record Header;
	public List<Record> Body;
}

public class Record
{
	public List<string> Data;
}
\end{lstlisting}

\begin{lstlisting} [caption = CSV tabellieren mit Dexel generierter Code]
// Operationen
public static IEnumerable<int> SpaltenbreitenErmitteln(Tabelle tbl)
{
    throw new NotImplementedException();
}

public static IEnumerable<string> HeaderFormattieren(IEnumerable<int> breiten, Tabelle tbl)
{
    throw new NotImplementedException();
}

public static IEnumerable<string> BodyFormattieren(IEnumerable<int> breiten, Tabelle tbl)
{
    throw new NotImplementedException();
}

public static IEnumerable<string> TabelleZusammensetzen(IEnumerable<string> body, IEnumerable<string> header)
{
    throw new NotImplementedException();
}

public static Tabelle HeaderVomBodyTrennen(IEnumerable<Record> records)
{
    throw new NotImplementedException();
}

public static IEnumerable<Record> CSVParsen(IEnumerable<string> strings)
{
    throw new NotImplementedException();
}
\end{lstlisting}

\subsubsection{Shopping Simulator - Komplexeres Beispiel}

\begin{landscape}
	\begin{figure}
		\vspace*{-1.5cm}
		\hspace*{-2cm}
		\makebox[\linewidth]{
			\includegraphics[width=1.15\linewidth]{./img/shoppingSimulator.png}
		}
		
		\caption{Shopping Simulator}
	\end{figure}
\end{landscape}




\begin{lstlisting}[caption=Shopping Simulator - automatisch generierter Code mit Dexel]
// Integration
public static void ShoppingSimulator(int customerCount)
{
	CreateRandomPersons(customerCount, person => {
		var aCart = CreateRandomShoppingCart();
		CheckAge(person, onAdult: () => {
			CheckMoney(person, aCart, onEnough: () => {
				Checkout(aCart, person);
				SubscribeToNewsletter(person);
			}, onTooExpensive: () => {
				PrintNotEnoughMoneyMessage();
			});
		}, onChild: () => {
			AddDiscount(aCart);
			CheckMoney(person, aCart, onEnough: () => {
				Checkout(aCart, person);
			}, onTooExpensive: () => {
				PrintNotEnoughMoneyMessage();
			});
		});
	});
}
\end{lstlisting}

\begin{lstlisting}[caption=Shopping Simulator - automatisch generierter Code mit Dexel]
// Datentypen
public class Person
{
	public int Age;
	public string Name;
	public double Budget;
}

public class Cart
{
	public List<string> Products;
	public double Discount;
	public double PriceTotal;
}
\end{lstlisting}


\begin{lstlisting}[caption=Shopping Simulator - automatisch generierter Code mit Dexel]
// Operationen
public static void CreateRandomPersons(int customerCount, Action<Person> onPerson)
{
	CreateNewPerson(customerCount, p => {
		var rndP = AddRndNameAndRndAge(p);
		onPerson(AddRndBudget(rndP));
	});
}

public static Cart CreateRandomShoppingCart()
{
    throw new NotImplementedException();
}

public static void CheckAge(Person aPerson, Action onAdult, Action onChild)
{
    throw new NotImplementedException();
}

public static void CheckMoney(Person aPerson, Cart aCart, Action onEnough, Action onTooExpensive)
{
    throw new NotImplementedException();
}

public static void AddDiscount(Cart aCart)
{
    throw new NotImplementedException();
}

public static void SubscribeToNewsletter(Person aPerson)
{
    throw new NotImplementedException();
}

public static void PrintNotEnoughMoneyMessage()
{
    throw new NotImplementedException();
}

public static void Checkout(Cart aCart, Person aPerson)
{
    throw new NotImplementedException();
}

public static void CreateNewPerson(int customerCount, Action<Person> onP)
{
    throw new NotImplementedException();
}

public static Person AddRndNameAndRndAge(Person p)
{
    throw new NotImplementedException();
}

public static Person AddRndBudget(Person rndP)
{
    throw new NotImplementedException();
}


\end{lstlisting}

\subsubsection{Aktueller Stand}

Die weniger komplexeren Aufgaben wurden vollständig implementiert.
Diese wären: 
\begin{itemize}
	\item Generierung der benutzerdefinierten Datentypen, und 
	\item Generierung der Methodensignaturen einer Funktionseinheit.
\end{itemize}

Die weitaus komplexere Aufgabe: die Generierung der Methodenrümpfe einer Integration wurde nicht ganz vollständig implementiert.
Das liegt vor allem daran, dass eine vollständige Umsetzung einiges an manuellem Testen erfordert, um herauszufinden, welche Datenströme noch falsch interpretiert werden. 

Die Validierung des Datenflusses ist eng an die Generierung gekoppelt und deswegen gilt das selbe auch für diese. 

Auch bei der Generierung von Namen wird aktuell noch nicht in jedem Fall überprüft, ob es zu einer Überschneidung kommt und ob gegebenenfalls der Name angepasst werden muss.

\bigskip

Um Code zu generieren muss im Editor in der Menüleiste der Eintrag Output angesteuert werden.
Hier gibt es die Möglichkeit das aktuelle Flow Design in eine Datei auf den Desktop zu
generieren, den Code in die Konsole auszugeben, oder den Code direkt in die Zwischenablage zu kopieren( um den erzeugten Code bequem an eine gewünschte Stelle eingefügt werden kann).

Außerdem gibt es die Option eine automatische Generierung einzuschalten, die
den Code während der Bearbeitung immer neu generiert und in die Datei
auf den Desktop schreibt. So lässt sich das Ergebnis der Generierung während der Bearbeitung
des Datenflusses beobachten (vor allem in Kombination mit einem
Texteditor, wie zum Beispiel Atom, die bei einer Änderung der Datei diese automatische neu laden).

Das Ergebnis wird auch immer mit in die Konsole ausgegeben, die beim
Programmstart mit geöffnet wird.


\subsection{Kleiner Einblick in die API von Roslyn}

Das Projekt Rosyln von Microsoft ist ein .NET-Compiler, der eine API bietet, um beliebigen C\#-Quelltext zu erstellten,
zu analysieren und zu modifizieren.

Das hier verwendetet Paket ist: Microsoft.CodeAnalysis

Der Datentypen auf dem die Methoden zum Erstellen von Code arbeitet lautet:
\texttt{SyntaxNode} 

Diese SyntaxNodes werden von einem SyntaxGenerator erstellt werden.
Diese muss beim Initialisieren konfiguriert werden.

\begin{lstlisting}[caption=SyntaxGenerator für C\# erhalten]
var workspace = new AdhocWorkspace();
// Get the SyntaxGenerator for the specified language
var generator = SyntaxGenerator.GetGenerator(workspace, LanguageNames.CSharp);
\end{lstlisting}


Das Erstellen eines Ausdruckes, Klasse oder Methode mit Hilfe von Methoden
des SyntaxGenerators liefern am Ende immer eine SyntaxNode zurück.
Beim Erstellen einer Methode oder Klasse kann der Inhalt des Scopes durch
ein Array von SyntaxNodes bestimmt werden.

Nachfolgend ein einfaches Beispiel zum Erstellen von einem
benutzerdefinierten Datentyp.


	\subsubsection{Erzeugung eines Datentypen als einfaches Beispiel}

	
	\begin{lstlisting}[caption=Erzeugung einer Person-Klasse mit Roslyn]
SyntaxNode fieldAlter = generator.FieldDeclaration(
	name: "Alter",
	type: generator.TypeExpression( SpecialType.System_Int32),
	accessibility: Accessibility.Public);

SyntaxNode fieldName = generator.FieldDeclaration(
	name: "Name",
	type: generator.TypeExpression( SpecialType.System_String),
	accessibility: Accessibility.Public);


SyntaxNode[] allFields =  new[] {fieldName, fieldAlter};


// Generate the class
SyntaxNode classDefinition = Generator.ClassDeclaration(
	"Person", 
	typeParameters: null,
	accessibility: Accessibility.Public,
	modifiers: DeclarationModifiers.None,
	baseType: null,
	interfaceTypes: null,
	members:allFields
);
	\end{lstlisting}
	
	Um am Ende den Code in Form eines Strings zu erhalten muss auf die oberste
	SyntaxNode folgende beide Methoden aufgerufen werden:
	
	\begin{lstlisting}[caption=Erhalten des Codes als string]
	string code = classDefinition.NormalizeWhitespace().ToFullString();
	\end{lstlisting}


\subsection{Erzeugung von Methodensignaturen}

Das Analysieren einzelner Funktionseinheiten anhand ihrer Ein- und Ausgänge erlaubt eine automatische Generierung der Methodensignaturen.
Dieses Feature wurde vollständig implementiert, da die möglichen Faktoren, die Einfluss auf die Methodensignatur haben überschaubar sind und somit alle Kombinationen sich schnell herauskristallisiert haben.

\subsubsection{Output über Rückgabewert}

	Der einfachste Fall ist eine Funktionseinheit, die nur ein Ausgang hat und
	dieser auch kein Stream und auch nicht optional ist.\footnote{Im Editor ist das vorhanden sein eines Eingangs vorgeben und es gibt auch keine Möglichkeit einen weiteren Eingangs-Datenstrom zu einer Funktionseinheit hinzuzufügen. Nur Ausgänge lassen sich hinzufügen und entfernen.}
	
	In diesem Fall werden die ausgehenden Daten einfach als Rückgabewert heraus gereicht.
	
	
	\begin{figure}[H]
		\centering
			\includegraphics[width=\linewidth]{./img/roslyn_simpleOutput.png} 
		\caption{Dexel-Screenshot: Einfache Funktionseinheit mit benutzerdefinierten Datentyp}
	\end{figure}

	
	Die Generierung erzeugt folgenden Code:
	\begin{lstlisting}[caption=Mit Dexel generierter Code ]
public class Person
{
	public string Name;
	public int Age;
}

public static Person NewPerson(int aint, string astring)
{
	throw new NotImplementedException();
}
	\end{lstlisting}
	
	Hat ein Output mehr als ein Datentyp und ist kein Stream und ist auch nicht optional, so
	wird das Ergebnis als Tupel über den Rückgabewert geliefert.
	
		\begin{figure}[H]
			\centering
			\includegraphics[width=.8\linewidth]{./img/roslyn_twoDatatypesOneOutput.png} 
			\caption{Dexel-Screenshot: Funktionseinheit mit Tupel-Output}
		\end{figure}

	
	
	\begin{lstlisting}[caption=Mit Dexel generierter Code ]
public static Tupel<Person, int> NewPerson(int aInt, string aString)
{
	throw new NotImplementedException();
}
	\end{lstlisting}

	
\subsubsection{Outputs über Actions}

	Ob ein Ausgang über ein Action realisiert wird, wird indirekt dadurch
	festgelegt, dass ein Actionname angegeben wurde \footnote{Diese Regel wurde im
		Rahmen dieser Anwendung so festgelegt}. 
	
	Ausgänge müssen nicht zwingend mit
	der Anzahl an Aufrufe der Funktionseinheit übereinstimmen. Ein Action muss
	nicht aufgerufen werden, oder kann bei einem einzigen Aufruf der Funktionseinheit auch
	mehrmals aufgerufen werden (der Beginn eines Streams). 
	
	Sobald auch eine Funktionseinheit mehrere Ausgänge hat, diese jedoch nicht
	optional sind, werden diese jedoch trotzdem als Actions realisiert, selbst wenn sie kein
	Actionname zugeordnet bekommen haben. Der Name des Actions wird dann
	automatisch generiert\footnote{	Durch Analyse der Datentypen. Ein
	(Person) wird zu einem onPerson. Ein () wird zu einem continueWith}.
	
	Durch diese Entscheidungen gibt es keine invaliden Kombinationen an
	Ausgängen einer Funktionseinheit.
	
	
	Werden alle Ausgänge mit Actions realisiert, entfällt der Rückgabewert in diesem Fall komplett.
	
	Die Input-Daten werden in der Signatur zuerst aufgelistet, anschließend die Actions.
	
			\begin{figure}[H]
				\centering
				\includegraphics[width=\linewidth]{./img/roslyn_multipleOutputs.png} 
				\caption{Dexel-Screenshot: Funktionseinheit mit zwei Outputs mit definierten Actionnamen}
			\end{figure}
			
	

	
	\begin{lstlisting}[caption=Mit Dexel generierter Code ]
	public static void NewPerson(int aint, string astring, Action<Person> onPerson, Action<string> onError)
	{
	throw  new NotImplementedException();
	}
	\end{lstlisting}
	 \subsubsection{Streams}

	Streams werden in Dexel ebenfalls mit Actions realisiert, mit einer Ausnahme:
	
	Sind ist sowohl der Eingang als auch der Ausgang ein Stream und ist der \textit{Actionname} dieses Ausgangs \textit{nicht} angegeben, so wird  implizit davon ausgegangen, dass für jeden Aufruf der Funktionseinheit dieser Ausgang erzeugt wird. 
	
	Somit kann für diesen Ausgang auf eine Action verzichtet werden und der Rückgabewert genutzt werden, was eine einfachere Verwendung dieser Funktionseinheit im Code zur Folge hat.
	\footnote{	Das Vorhandensein von einem Inputstream und einem Outputstream bedeutet eigentlich nicht zwingend , dass für jeden Input auch ein Output erzeugt wird. Die Notation unterscheidet beide Fälle nicht. Deswegen die Lösung über eine Vergabe eines \textit{Actionnamen} als Kompromiss zu sehen, wodurch dem Benutzer hier eine Kontrolle über die Erzeugung des Codes geben wird. Wenn der Benutzer ein \textit{Actionname} angibt, wird indirekt davon ausgegangen, dass der Benutzer den Output auch als Action umsetzten möchte und die Funktionseinheit somit beliebig oft diese Action aufrufen kann. Ob dieses Entscheidung richtig war müsste  noch in der Praxis erprobt werden. Stellt sich heraus,	dass sie schlecht ist, müsste man über eine Anpassung der Notation nachdenken.}
	
	\begin{figure}[H]
		\centering
		\includegraphics[width=.9\linewidth]{./img/roslyn_Stream.png} 
		\caption{Dexel-Screenshot: Funktionseinheit mit Stream als Ausgang}
	\end{figure}
	


	
	
\begin{lstlisting}[caption=Mit Dexel generierter Code ]
public static void NewPersons(int aInt, string aString, Action<Person> onPerson)
{
	throw new NotImplementedException();
}
\end{lstlisting}
	
		
	\begin{figure}[H]
		\centering
		\includegraphics[width=.9\linewidth]{./img/roslyn_StreamStream.png} 
		\caption{Dexel-Screenshot: Funktionseinheit mit eingehendem und ausgehendem Stream und undefinierten Actionnamen}
	\end{figure}
			

	\begin{lstlisting}[caption=Mit Dexel generierter Code ]
public static Person NewPersons(int age, string name)
{
	throw new NotImplementedException();
}
	\end{lstlisting}
	 

\subsection{Erzeugung des Methodenrumpfes einer Integration}
\label{sec:orgheadline51}


	 \subsubsection{Terminologie}

	Eine Integration kann nicht nur aus
	Operationen bestehen, sondern auch aus anderen Integrationen bestehen.
	Leider gibt es hierfür keine Überbegriff für beide.
	Da im in diese Kapitel jedoch öfters von Funktionseinheiten innerhalb einer
	Integration die Rede sein wird, muss hierfür ein Überbegriff eingeführt
	werden. Funktionseinheiten, die sich in einer Integration befinden, werden
	nachfolgend als Sub-Funktionseinheiten bezeichnet.
	
	\subsubsection{Die Herangehensweise}

	
	Die automatische Erzeugung eines Integration ist die komplexeste Aufgabe in
	diesem Projekt. Um die Aufgabe überschaubar zu halten, wurde diese im Groben in
	zwei Teileaufgaben zerteilt: die Analyse und die Generierung.
	Die Analyse besteht wiederum aus unterschiedlichen Methoden, die jeweils das
	Flow Design auf eine bestimme Sache analysieren und das Ergebnis in ein Objekt
	abspeichern. Diese Objekt wurde als \texttt{IntegrationBody} bezeichnet.
	Diese beinhaltet alle Informationen aus der Analyse. Am Ende wird dieses Objekt
	der Generierungsmethode übergeben, die anhand diesem den Code erzeugt\footnote{Ein weiterer Vorteil dieser Aufteilung ist, dass ein großer Teil frei von der Roslyn-API bleibt. Die eigenen Datentypen lassen sich dazu auch besser testen, als die SyntaxNodes von Roslyn. Möchte man das Ergebnis von Roslyn testen, bleibt einem  oft keine andere Wahl, als den erzeugten Code samt Whitespaces über ein String-Vergleich zu erschlagen, was bei mehrzeiligem Code doch etwas ausufern kann. Stattdessen lässt sich das Ergebnis aus den eigenen Analysen hingegen einfach über ein Vergleich von den gefundenen Objekt-Referenzen überprüfen.}.
	
	\begin{lstlisting}[caption=GenerateIntegrationBody Methode]
public static SyntaxNode[] GenerateIntegrationBody( SyntaxGenerator generator, MainModel mainModel, FunctionUnit integration )
{
	// integrationbody object for storing analysed and generated information
	var integrationBody = IntegrationAnalyser.CreateNewIntegrationBody( mainModel.Connections, integration);
	AddIntegrationInputParameterToLocalScope(integrationBody, integration);
	
	// analyse data flow before generation 
	IntegrationAnalyser.AnalyseParameterDependencies( integrationBody);
	IntegrationAnalyser.AnalyseLambdaBodies( integrationBody, mainModel);
	IntegrationAnalyser.AnalyseMatchingOutputOfIntegration( integrationBody, mainModel);
	IntegrationAnalyser.AnalyseReturnToLocalReturnVariable( integrationBody, mainModel);
	
	// generation
	var result = new List<SyntaxNode>();
	integrationBody.Generator = generator;
	GenerateBody(integrationBody, result.Add);
	
	return result.ToArray();
}
	\end{lstlisting}
	
	\subsubsection{Analyse des Flow Designs}

	\begin{enumerate}
		\item \texttt{AnalyseParameterDependencies}

		Da die Pipe-Notation unterstützt wird, reicht es nicht einfache aus die Daten
		aus den Datenflüssen zu nehmen, die direkt in die aktuelle
		Funktionseinheit fließen. Stattdessen muss der Fluss rückwärts
		traversiert werden und auf Übereinstimmungen untersucht werden.
		Für jede Sub-Funktionseinheit muss diese Analyse durchgeführt werden.
		Für jeden Input-Datentyp jeder Funkionseinheit wird das Ergebnis gespeichert. Das Ergebnis beinhaltet ob der Datentyp überhaupt gefunden
		wurde, ob er im Eingang der Integration gefunden wurde, oder ob er aus einer
		anderen Sub-Funktionseinheit innerhalb des Datenflusses stammt. 
		Außerdem wird die gefundene DataStreamDefinition gespeichert, in der die
		Daten gefunden wurden. Ein Aufruf einer Sub-Funktionseinheit kann nur generiert werden, wenn alle Datentypen gefunden
		wurden.
		
		\item \texttt{AnalyseLambdaBodies}

		Manche optionale Datenflüsse oder Stream werden über Actions realisiert.
		Das bedeutet, dass sich alle nachfolgenden Funktionseinheiten innerhalb
		des Lambda-Ausdruckes befinden müssen. Die Analyse speichert das Ergebnis
		in folgender Form ab. 
		
		\begin{lstlisting}[caption=LambdaBody Klasse]
public class LambdaBody
{
	public DataStreamDefinition InsideLambdaOf;
	public FunctionUnit FunctionUnit;
}
		\end{lstlisting}
		
		Da die LambdaBody-Objekte in der Reihenfolge im IntegrationBody abgelegt
		werden, in der sie im Flow Design vorkommen, kann daraus auch später die
		Reihenfolge der zu generierenden Methoden abgeleitet werden.
		
		
		Für jede Funktionseinheit wird solch ein Objekt angelegt, auch wenn es
		nicht innerhalb eines Lambdas vorkommt. Ist das der Fall, so ist der Wert
		\texttt{InsideLambdaOf} \texttt{null} . Alle Funktionseinheiten für die dieser Wert
		\texttt{null} ist, befinden sich somit direkt im Scope der Integration und nicht
		innerhalb eines Lambdas.
		
		\item \texttt{AnalyseMatchingOutputOfIntegration}

		Hat die Integration einen Ausgang der als Action realisiert werden muss, so
		muss herausgefunden werden, welche Sub-Funkionseinheiten diesen
		Ausgang bedienen. Dabei werden die Implementierungs-Stile der
		beiden übereinstimmenden Ausgänge mit abgespeichert. Später bei der
		Generierung gibt es somit vier Möglichkeiten:
		\begin{itemize}
			\item Beide sind Actions
			
			Die Action der Integration wird direkt an die Sub-Funktionseinheit
			weitergereicht. Dadurch erlaubt man einer Sub-Funktionseinheit das
			Aufrufen des Ausgang der Integration.
			
			\begin{lstlisting}[caption=Action-Action-Beziehung]
// Integration
public static void Main(Action<string> onError)
{
	DoSomething(onError);
}

// Operation
public static void DoSomething(Action<string> onError)
{
	throw new NotImplementedException();
}
			\end{lstlisting}
			
			
			\item Integrationsausgang ist Action, Sub-Funktionseinheitsausgang ist
			Rückgabewert 
			
			Die Action wird aufgerufen mit dem Methodenaufruf als Parameter.
			
\begin{lstlisting}[caption=Action-Return-Beziehung]
public static void CreateRandomPersons(int customerCount, Action<Person> onPerson)
{
	CreateNewPerson(customerCount, p => {
		var rndP = AddRndNameAndRndAge(p);
		onPerson(AddRndBudget(rndP));
	});
}
\end{lstlisting}
			\item Integrationsausgang ist Rückgabewert, Sub-Funktionseinheitsausgang ist
			Action.
			
			Eine lokale Variable muss vorher angelegt werden und mit \texttt{null}
			initialisiert werden. Danach wird innerhalb des Lambdas des Actions diese
			Variable beschrieben. Am Ende wird die lokale Variable als Rückgabewert
			ausgegeben.
			
\begin{lstlisting}[caption=Return-Action-Beziehung]
public static void TryGetMessage(Action<string> onError)
{
	throw new NotImplementedException();
}

public static string Main()
{
	string @return = null;
	TryGetMessage(msg =>  @return = msg );
	return @return;	
}
\end{lstlisting}

			\item Beide Ausgänge werden über Rückgabewert realisiert
			
		    Das Ergebnis der Sub-Funktionseinheit wird durch ein Rückgabewert-Ausdruck aus der Integration heraus gereicht.
		    
\begin{lstlisting}[caption=Return-Return-Beziehung]
public static string GetMessage()
{
	throw new NotImplementedException();
}

public static string Main()
{
	var msg = GetMessage();
	return msg;
}
\end{lstlisting}		    
		    
		\end{itemize}
			\item \texttt{AnalyseReturnToLocalReturnVariable}
			
			Wird der Ausgang einer Integration mit dem Rückgabewert realisiert, so muss noch herausgefunden werden, ob eine lokale Variable nötig ist, um den Rückgabewert aus
			einem Lambda heraus zu reichen. Ist eine Return-Return-Beziehung vorhanden und befindet sich die betroffene Methode innerhalb eines Lambda-Ausdrucks, so muss der Rückgabewert in die lokale \texttt{@return}-Variable geschrieben werden.
	\end{enumerate}
	



\section{Generierung eines Diagrammes aus Code}

Aus zeitlichen Gründen, konnte die Generierung von einem Flow Design aus Code nicht angegangen werden. 
Da sich das Modell jedoch sauber getrennt von der GUI in
einem separaten Unterprojekt befindet, wäre es sicherlich möglich einen anderen
Studenten dies als Projekt zu übergeben. So hätte dieser bereits eine
Möglichkeit seine Diagramme darzustellen, ohne sich sonderlich in die
Codebasis von dem gesamten Dexel-Projekts einarbeiten zu müssen.
