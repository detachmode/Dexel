\BOOKMARK [1][-]{section.1}{Entstehung und Grundgedanken}{}% 1
\BOOKMARK [2][-]{subsection.1.1}{DRAFT Einleitung}{section.1}% 2
\BOOKMARK [2][-]{subsection.1.2}{FRAGEN CCD Prinzipien}{section.1}% 3
\BOOKMARK [3][-]{subsubsection.1.2.1}{KISS}{subsection.1.2}% 4
\BOOKMARK [3][-]{subsubsection.1.2.2}{YAGNI}{subsection.1.2}% 5
\BOOKMARK [3][-]{subsubsection.1.2.3}{Lose Koppelung}{subsection.1.2}% 6
\BOOKMARK [3][-]{subsubsection.1.2.4}{Orthogonalit\344t}{subsection.1.2}% 7
\BOOKMARK [2][-]{subsection.1.3}{DRAFT Weitere Prinzipien die Beachtung find sollen}{section.1}% 8
\BOOKMARK [3][-]{subsubsection.1.3.1}{DRY}{subsection.1.3}% 9
\BOOKMARK [3][-]{subsubsection.1.3.2}{kleine Funktionen}{subsection.1.3}% 10
\BOOKMARK [3][-]{subsubsection.1.3.3}{TODO Single Responsibiltiy Principle}{subsection.1.3}% 11
\BOOKMARK [3][-]{subsubsection.1.3.4}{Separation of Concerns}{subsection.1.3}% 12
\BOOKMARK [3][-]{subsubsection.1.3.5}{Information Hiding Principle}{subsection.1.3}% 13
\BOOKMARK [3][-]{subsubsection.1.3.6}{Dependency Injection}{subsection.1.3}% 14
\BOOKMARK [2][-]{subsection.1.4}{DRAFT Flow Design - Was ist das?}{section.1}% 15
\BOOKMARK [2][-]{subsection.1.5}{Referenzen}{section.1}% 16
\BOOKMARK [1][-]{section.2}{Pfeile und Kreise}{}% 17
\BOOKMARK [2][-]{subsection.2.1}{DRAFT RomanNumbers Beispiel}{section.2}% 18
\BOOKMARK [2][-]{subsection.2.2}{MISSING IMAGES Hirarchische Datenfl\374sse}{section.2}% 19
\BOOKMARK [1][-]{section.3}{Notationen}{}% 20
\BOOKMARK [2][-]{subsection.3.1}{MISSING IMAGES Datentypen}{section.3}% 21
\BOOKMARK [2][-]{subsection.3.2}{MISSING IMAGES Definition eigener Datentypen}{section.3}% 22
\BOOKMARK [2][-]{subsection.3.3}{MISSING IMAGES Arrays \(auch mit fester Gr\366\337e\)}{section.3}% 23
\BOOKMARK [2][-]{subsection.3.4}{FRAGEN 0 bis n \(Datenstrom\)}{section.3}% 24
\BOOKMARK [2][-]{subsection.3.5}{FRAGEN Container / Listen}{section.3}% 25
\BOOKMARK [2][-]{subsection.3.6}{FRAGEN 0 bis 1 \(optionaler Output\)}{section.3}% 26
\BOOKMARK [2][-]{subsection.3.7}{MISSING IMAGES Mehrere Inputs / Outputs auf einem Weg}{section.3}% 27
\BOOKMARK [2][-]{subsection.3.8}{DONE Joined Inputs}{section.3}% 28
\BOOKMARK [2][-]{subsection.3.9}{FRAGEN Tonnen}{section.3}% 29
\BOOKMARK [2][-]{subsection.3.10}{FRAGEN Anh\344ngigkeiten / Provider}{section.3}% 30
\BOOKMARK [2][-]{subsection.3.11}{MISSING IMAGES GUIS / Programmstart/ Ende}{section.3}% 31
\BOOKMARK [2][-]{subsection.3.12}{DRAFT Klassen / Container definieren}{section.3}% 32
\BOOKMARK [2][-]{subsection.3.13}{Referenzen}{section.3}% 33
\BOOKMARK [1][-]{section.4}{Implementation}{}% 34
\BOOKMARK [2][-]{subsection.4.1}{IODA Architekur}{section.4}% 35
\BOOKMARK [3][-]{subsubsection.4.1.1}{DRAFT Erl\344uterung des Schaubildes}{subsection.4.1}% 36
\BOOKMARK [3][-]{subsubsection.4.1.2}{DRAFT PoMO \( Principle of Mutual Oblivion\)}{subsection.4.1}% 37
\BOOKMARK [3][-]{subsubsection.4.1.3}{DRAFT IOSP \( Integration Operation Segregation Principle\)}{subsection.4.1}% 38
\BOOKMARK [3][-]{subsubsection.4.1.4}{DONE Tabelle - IOSP auf einen Blick}{subsection.4.1}% 39
\BOOKMARK [2][-]{subsection.4.2}{DONE Beispiel foreach und Funktionsaufruf als negativ Beispiel.}{section.4}% 40
\BOOKMARK [2][-]{subsection.4.3}{C\043 Features um Datenfl\374sse zu implementieren}{section.4}% 41
\BOOKMARK [3][-]{subsubsection.4.3.1}{DRAFT LINQ und Lambdas}{subsection.4.3}% 42
\BOOKMARK [3][-]{subsubsection.4.3.2}{DRAFT yield return}{subsection.4.3}% 43
\BOOKMARK [2][-]{subsection.4.4}{FRAGEN Datenstr\366me mit mehreren Wegen}{section.4}% 44
\BOOKMARK [3][-]{subsubsection.4.4.1}{Ein Output-Weg mehrer Empf\344nger}{subsection.4.4}% 45
\BOOKMARK [3][-]{subsubsection.4.4.2}{DRAFT Mehrere Output-Wege}{subsection.4.4}% 46
\BOOKMARK [3][-]{subsubsection.4.4.3}{FRAGEN mit und/oder den Kontrollfluss notieren.}{subsection.4.4}% 47
\BOOKMARK [2][-]{subsection.4.5}{Weitere Beispiele was erlaubt ist und was nicht erlaubt ist.}{section.4}% 48
\BOOKMARK [3][-]{subsubsection.4.5.1}{DONE R\374ckgabewert erwarten von Funktion als Parameter \374bergeben.}{subsection.4.5}% 49
\BOOKMARK [3][-]{subsubsection.4.5.2}{FRAGEN API-Aufruf, Filehandling?, Daten in Integrationen?}{subsection.4.5}% 50
\BOOKMARK [2][-]{subsection.4.6}{Warum macht man das? Sinn der Aufteilung.}{section.4}% 51
\BOOKMARK [3][-]{subsubsection.4.6.1}{DRAFT Die Perlenkette}{subsection.4.6}% 52
\BOOKMARK [3][-]{subsubsection.4.6.2}{FRAGEN Gr\366\337tes \334bel funktionale Abh\344ngigkeiten.}{subsection.4.6}% 53
\BOOKMARK [3][-]{subsubsection.4.6.3}{Optional}{subsection.4.6}% 54
\BOOKMARK [2][-]{subsection.4.7}{DRAFT Ausnahmen}{section.4}% 55
\BOOKMARK [3][-]{subsubsection.4.7.1}{FRAGEN Rekursion}{subsection.4.7}% 56
\BOOKMARK [3][-]{subsubsection.4.7.2}{DONE Integrationen}{subsection.4.7}% 57
\BOOKMARK [2][-]{subsection.4.8}{FRAGEN Zusammenfassung}{section.4}% 58
\BOOKMARK [2][-]{subsection.4.9}{Leserlichkeit}{section.4}% 59
\BOOKMARK [3][-]{subsubsection.4.9.1}{Integration gibt Funktionspointer an Operationen, welche diesen jedoch auch nur an die n\344chste Operation weitergibt.}{subsection.4.9}% 60
\BOOKMARK [1][-]{section.5}{Die Entwurfsmethode}{}% 61
\BOOKMARK [2][-]{subsection.5.1}{TODO Definieren der Portale und Provider}{section.5}% 62
\BOOKMARK [2][-]{subsection.5.2}{TODO Interfaceskizze \( im Falle einer GUI Anwendung \)}{section.5}% 63
\BOOKMARK [2][-]{subsection.5.3}{TODO Flow Design Entwurf}{section.5}% 64
\BOOKMARK [2][-]{subsection.5.4}{FRAGEN Einordnen der Funktionseinheiten in bestimmte Container}{section.5}% 65
\BOOKMARK [2][-]{subsection.5.5}{FRAGEN Optional - Bestimmen von Parallelit\344ten}{section.5}% 66
\BOOKMARK [1][-]{section.6}{TODO Rekursive Eigenschaft}{}% 67
\BOOKMARK [1][-]{section.7}{Backlog}{}% 68
\BOOKMARK [2][-]{subsection.7.1}{Einfaches Beispiel eines Flow Designs}{section.7}% 69
\BOOKMARK [3][-]{subsubsection.7.1.1}{Negativ Beispiel}{subsection.7.1}% 70
