* Realisierung ( ~ 20- 30 Seiten )
In diesem Kapitel soll vorgestellt werden, was in dem Zeitraum dieser
Bachelorarbeit erreicht wurde. Es soll die Funktionalität des Editors
anhand von Screenshots vorgestellt werden und die Architekur der Anwendung, die selbst nach
Flow Design umgesetzt wurde. 

Als Arbeitstitel für die Anwendung wurde der Name Dexel gewählt.

** Übersicht über die unterschiedlichen Projekte

Die Anwendung besteht aus einer Solution, die aus folgenden Projekten:
(Fußnote: Bei komplexen Funktionalitäten wurde nach TDD (Test Driven Development)
programmiert, bei dem zuerst der Test geschrieben wird, der das zu erwartende
Ergebnis definiert, und anschließend wurd die Methode erst implementiert, diese
Tests werden in einem extra Test-Projekt für jedes Projekt zusammengefasst)

*** Dexel.Model / Dexel.Model.Tests
    Dieses Projekt beinhaltet alle Datentypen die zur internen Repräsentation
    eines Flow Design Diagrammes nötig sind. Außerdem beinhaltet dieses Projekt
    statische Manager-Klassen, die das Arbeiten mit den Datentypen vereinfachen.

*** Dexel.Editor / Dexel.Editor.Tests
    Das Hauptprojekt, das alle anderen Projekte integriert. Hier wurde das IOSP
    Prinzip nicht eingehalten. Dieses Projekt hat nicht nur die Aufgabe die
    anderen Projekte zu integrieren, sondern beinhaltet selbst den
    UI-Sourcecode. Diese Entscheidung wurde gefällt, da ein Extrahieren der UI
    in ein anderes Projekt sich als zu schwierig erwies. Eine Lösung dafür zu
    finden, wie ein Event aus dem UI mit einer Funktionalität verbunden werden
    könnte, aus einem Projekt, welches es selbst nicht, war zeitlich zu
    aufwendig. Aus diesem Grund wurde entschieden auf die zusätzliche
    Komplexität einer Entkoppelung zu verzichten und der Einfachheit halber
    dieses Projekt als UI und integrierendes Projekt zu nutzen.

*** Roslyn / Rosyln.Tests
    Diese Projekt beinhaltet die Logik zur Erstellung von C#-Code aus einem Flow
    Design. Mircosoft Rosyln ist die Technik, die hier zum Erstellen von Code zum
    Einsatz kommt.
    Das Flow Design Diagramm muss in Form eines Mainmodels aus dem
    Dexel.Model Projekt vorliegen. Aus diesem Grund gibt es eine Abhängigkeit
    zwischen diesem Projekt und dem Dexel.Model Projekt. 

    Eine Trennung dieser Abhängigkeit wurde versucht umzusetzen indem gegen ein Interface
    programmiert wurde, anstatt gegen die konkrete Implementation in
    Dexel.Model. Diese Interfaces der Datentypen und Manager-Klassen wurde dann
    in ein Contracts-Projekt ausgelagert, von dem alle anderen Projekte abhängig
    sein durften. Die zusätzliche Komplexität, Mehraufwand und ein Problem bei
    der Serialisierung von Datentypen, bestehend aus weiteren Interfaces als
    Properties, machte die Entkoppelung nicht wert und der Beschluss auf die
    Interfaces zu verzichten wurde gefällt.
    
*** Dexel.Library
    Beinhaltet einige Methoden ( meist Extension-Methoden), die ein Arbeiten
    nach Flow Design erleichter. Diese wurden in ein separates Projekt
    ausgelagert, damit alle anderen Projekte darauf zugreifen können.

** Das Model
   Um nachfolgende Kapitel der Realisierung und die darin enthaltenden
   Codeauschnitte verstehen zu können, braucht es ein Verständnis darüber, wie die
   grundlegenden Datentypen des Models aufgebaut sind. Um die Funktionalität der
   jeweiligen Datentypten besser zu veranschaulichen, werden in diesem Kapitel
   Bilder verwendet, welche die spätere Darstellung des Datentypen in der UI zeigen.

*** MISSING IMAGES MainModel
    Das MainModel ist, wie der Name schon sagt, das Haupt-Modell, das alle
    anderen Modelle per Komposition beinhaltet. Somit kann man eine Objektinstanz
    eines MainModels an eine Methode übergeben und diese Instanz beinhaltet alle
    Informationen über das aktuelle Flow Design Diagramm. 
    Das MainModel beinhaltet alle Funktonseinheiten (=SoftwareCells=), alle verbindende
    Datenströme (=Connections=) und alle benutzerdefinierten Datentypen (=DataTypes=).

#+BEGIN_SRC cpp 
    [ImplementPropertyChanged]
    public class MainModel
    {
        public List<SoftwareCell> SoftwareCells { get; set; }
        public List<DataStream> Connections { get;  set; }
        public List<DataType> DataTypes { get; set; } 
    }
#+END_SRC

*** MISSING IMAGES SoftwareCell
    In Anlehnung an den Gedanken der Softwarezellen-Architekur und den Schluss
    daraus, dass auf unterster Ebene eine Funktionseinheit auch als
    Softwarezellen gedacht werden kann, wurden Funktionseinheiten als
    Softwarezellen bezeichnet.

#+BEGIN_SRC cpp
    [ImplementPropertyChanged]
    public class SoftwareCell
    {
        public Guid ID { get; set; }
        public string Name { get; set; }
        public Point Position { get; set; }
        public List<SoftwareCell> Integration { get; set; }
        public List<DataStreamDefinition> InputStreams { get; set; }
        public List<DataStreamDefinition> OutputStreams { get; set; }
    }
#+END_SRC

    Der Name ist der Name der Funktionseinheit ( der Text, der bei der
    Darstellung später innhalb des Kreises erscheint). Dieser wird später per Binding
    direkt an die UI gebunden. Aus diesem Grund implementiert dieses Klasse,
    genau wie alle anderen des Models, die ImplementPropertyChanged
    Funktionalität. Diese bewirkt, dass bei einer Änderung im UI automatisch das
    entsprechende Property im Model aktualisiert wird und umgekehrt.

    Die Position beschreibt die Position der Softwarezelle innherhalb des
    Diagrammes.  

    Das Integration Property gibt an, ob diese Softwarezelle eine Integration
    ist und welche andere Instanzen von Softwarezellen sie integriert.
    Eine leere Liste besagt, dass die Softwarezelle keine Integration ist.

    Die Input- und OutputStreams definieren die möglichen ein- und ausgehenden
    Datenströme der Softwarezelle. An diese DataStreamDefinitionen können sich DataStreams
    verbinden. Dadurch lassen sie die Datenflüsse modelieren.

**** MISSING IMAGES DataStreamDefinition

#+BEGIN_SRC cpp
    [ImplementPropertyChanged]
    public class DataStreamDefinition
    {
        public Guid ID { get;  set; }
        public string DataNames { get;  set; }
        public string ActionName { get;  set; }
        public SoftwareCell Parent { get;  set; }
        public bool Connected { get;  set; }
    }
#+END_SRC

     Eine Funktionseinheit verfügt über ein oder mehrere ein- und ausgehende
     DataStreamDefinitionen. Diese können verbunden sein oder nicht. Wenn eine
     Verbindung erstellt und gelöscht wird, muss deshalb auch das Connected
     Property immer gesetzt werden, damit das Model valide bleibt.
     Ob eine DataStreamDefinition verbunden ist, oder nicht, ist vorallem später
     für die Darstellung relevant.
     Eine DataStreamDefinition kennt auch die Funktionseinheit, von der sie ein
     Ein- oder Ausgang ist.
     
     Eine weitere grundlegende Eigenschaft ist die Benennung der Daten, die in/aus
     dem Ein-/ Ausgang fließen. Für Ausgänge ist auch die Angabe eines
     Actionnames manchmal nötig. Dieser soll später unterhalb des Pfeiles
     dargstellt werden.

*** MISSING IMAGES DataStream (Connections)
    Um Datenflüsse zwischen Funktionseinheitn zu beschreiben, bedarf es einer
    Verbindungsklasse. Die DataStream-Klasse stellt diese Verbindungsklasse dar.
 

#+BEGIN_SRC cpp
    [ImplementPropertyChanged]
    public class DataStream
    {
        public Guid ID { get; set; }
        public string DataNames { get;  set; }
        public List<DataStreamDefinition> Sources { get;  set; }
        public List<DataStreamDefinition> Destinations { get;  set; }

    }
#+END_SRC

    Ein DataStream hat ein oder mehrere Referenzen an DataStreamDefinition als
    Quellen und ein oder mehrere Referenzen an DataStreamDefinition als Ziele.
    Um ein Datenstrom zu beschreiben, der aus mehren Quellen Daten bezieht und
    an einer Stelle zusammenläuft, benötigt man ein DataStream, der mehrer
    Einträge in der Source-Liste besitzt und ein Eintrag in der
    Destination-Liste. Diese Datenstrom wäre dann ein Joint-Input.
    Ein Datenstrom mit einer Quelle und mehreren Zielen wäre ein Joint-Output ( TODO:
    Referenz auf vorheriges Kapitel)
    
    Das DataNames Property stellt den Text dar, der später in der Mitte des
    Pfeiles dargestellt werden soll. Eine Änderung dieser Eigenschaft bedarf
    einer Aktualisierung der DataNames aller Sources und Destinations.
    Eine Aktualisierung muss die optionalen Pipe-Notation kennen und
    entsprechend dieser die Ein und Ausgänge akutalisieren.

    Der akutelle Stand der UI kann akutell nur Datenflüsse mit einer Quelle und
    einem Ziel darstellen.

*** DataType

#+BEGIN_SRC cpp

  [ImplementPropertyChanged]
    public class CustomDataType
    {
        public string Name { get; set; }
        public List<SubDataType> SubDataTypes { get; set; }
    }

    [ImplementPropertyChanged]
    public class SubDataType
    {
        public string Name { get; set; }
        public string Type { get; set; }
    }

#+END_SRC

  Ein benutzerdefinierter Datentyp besteht aus einem Namen und einer Liste von mehreren
  =SubDataType=-Objekten. 

  Ein SubDataType besteht aus einem Namen und den Namen
  des Types (zum Beispiel string, int oder auch ein anderen benutzerdefinierten
  Datentypen).

*** Manager-Klassen
**** MainModelManager 
     Einer der relevantesten Manager-Klassen ist die MainModelManager-Klasse,
     diese stellt die wichtigsten Funktionalitäten zur Verfügung die mit dem
     Arbeiten des MainModels gebraucht werden. Einige dieser Funktionalitäten
     wären: Verbinden und Trennen von Funktionseinheiten, vorwärts und rückwärts
     Traversieren entlang des Graphen, Hinzufügen und Entfernen einer
     Funktionseinheit von einer Integration, Hinzufügen, Löschen und Duplizieren
     von Funktionseinheiten, oder Teile des Graphen.

**** DataStreamManager 
     Diese statische Klasse bietet einige Funktionalitäten, die das Arbeiten mit
     Objekten der DataStream-Klasse vereinfachen soll.

     Ein Beispiel hierfür wäre das Ändern des Datanames eines DataStreams. 
     Wie bereits in letzten Abschnitt erwähnt, muss beim Ändern der Daten
     eines Datenflusses auch die Daten seiner Sources und Destinations
     angepasst werden. 

     Um dies nochmal zu verdeutlichen, zwei konkrete Beispiele:
     Falls der Datenfluss auf (int)|(string) geändert werden
     soll, muss die Source-DataStreamDefinition auf (int) gesetzt werden und der
     die Destination-DataStreamDefinition auf (string). 
     Falls der Datenfluss auf (double) geändert werden soll, so werden Source
     und Destination Daten auf (double) gesetzt.

     Fussnote: Da aktuell nur DataStreams mit einer Source und einer Destination im Editor unterstützt
     werden, wurde akutell auch nur dieses Szenario implementiert. Ändert sich
     diese Einschränkung müsste man sich Gedanken darüber machen, was in diesen
     Fällen zu tun wäre. Ein Option wäre, die Pipe-Notation in diesen Fällen zu
     verbieten. Die UI würde die Daten der DataStreamDefinitionen direkt
     anzeigen und der Benutzer würde diese dann direkt ändern. Der Datenstrom
     selbst würde dann kein eigenes Textfeld besitzen und die Dataname
     Eigenschaft hätte in diesen Fall keine Bedeutung. 
     Vielleicht wäre es dann auch besser im Modell zwei separate Klassen
     anzulegen und die
     einfache DataStream-Klasse hätte anstatt einer Liste von DatastreamDefinitionen nur noch ein einfaches Feld
     für eine Source-DataStreamDefinition und eine Destionation-DataStreamDefinition.
 
#+BEGIN_SRC cpp

 public static void ChangeDatanames(DataStream datastream, string newDatanames)
        {
            // update datanames of connection itself
            datastream.DataNames = newDatanames;

            // update datanames of DSDs
            TrySolveWithPipeNotation(newDatanames,
                onSuccess: (outputPart, inputPart) =>
                {
                    // TODO: doesn't support mutliple sources yet
                    datastream.Sources.First().DataNames = outputPart;
                    datastream.Destinations.First().DataNames = inputPart;
                },
                onNoSuccess: () =>
                {
                    // TODO: doesn't support mutliple destinations yet
                    datastream.Sources.First().DataNames = newDatanames.Trim();
                    datastream.Destinations.First().DataNames = newDatanames.Trim();
                });
        }
#+END_SRC



** Der Editor
*** Vorstellung was erreicht wurde

Die Grundlegenden Basisfunktionen aus Kaptitel 3 wurden größtenteils
implementiert. Hierbei kam WPF als GUI-Framework zum Einsatz.
Im folgendem einige Bilder und Beschreibungen der GUI und Interaktionen.

**** MISSING IMAGES Erstellen von Funktionseinheiten, Verschieben, Benennen, Selektieren
     Das Drawing-Board wurde implementiert, auf dem der Benutzer mit einem
     Rechtsklick->Create New Function Unit eine erste Funktionseinheit erzeugen
     kann. Per Drag an Drop kann er diese dann innerhalb des DrawingBoards frei
     verschieben. Mit einer Rect-Selektion ist es mögliche mehrere
     Funktionseinheiten zu Selektieren. Selektierte Funktionseinheiten können
     gemeinsam verschoben, dupliziert und gelöscht werden.
     
     Nach dem Erstellen einer neuen Funktionseinheit, wird diese automatisch
     selektiert und der Tastaturfokus wird in das Textfeld des Kreises gesetzt.
     Durch lässt sich diese Benennen.

     Beim Klicken auf den äußeren Teil des Kreises wird die Funktionseinheit
     selektiert. Beim Klicken auf das Textfeld, wechselt der Tastaturfokus auf
     das Textfeld ( ein Mouse-Hover zeigt auch an, über welchen Teil des Kreises
     man sich gerade befindet, auch ein Klicken und Ziehen um sofort ein Teil
     des Textes zu markieren bleibt damit dem Benutzer möglich. Wie er es von
     einem Textfeld gewohnt ist).


**** MISSING IMAGES Erstellen/Löschen/Manipulieren von Inputs und Outputs
     Eine Funktionseinheit wird standardmässig mit einem Input und einem Output
     erstellt. Die Daten die aus diesen hinein- oder herausfließen können auf
     dem Textfeld eingetragen werden. Dabei bietet diese Textfeld ein einfaches
     Syntaxhighlighting, dass mit Doppelpunkt getrennte Namen-Type-Paare
     farblich trennt. Auch Symbole wie * | [] () , ... haben eine eigene Farbe.

     Der Action-Name kann unterhalb des Pfeiles eingetragen werden.

     Eine Funktionseinheit kann mehr als nur einen Output besitzen.
     Zum Hinfzufügen eines neuen Outputs: Rechtsklick -> Add New Output
     Das Löschen eines Outputs ist durch auch möglich: Rechtsklick auf ein
     Output -> Delete.    
     
     Die Reihenfolge bei mehreren Outputs kann per Drag and Drop verändert werden.

**** MISSING IMAGES Verknüpfen und Trennen von Funktionseinheiten über Drag and Drop
     Wird das Ende eines Pfeiles eines Output auf ein Input Pfeil gedropt, so werden beide
     miteinandern Verbunden. Die Datennamen des Flusses werden bei nicht
     Übereinstimmung der beiden Daten des Input und Outputs mit
     der Pipe-Notation beschrieben. Stimmen beide Überein, kann darauf
     verzichtete werden.
     
     Werden die Daten eines verbundenen Datenflusses geändert, werden die Inputs
     und Outputs mit Berücksichtigung auf die Pipe-Notation angepasst, sodass
     beim Trennen der Beiden Funktionseinheiten, die Änderungen erhalten bleiben.

     Ein Drag and Drop eines Outputs direkt auf eine Funktionseinheit: TODO

     Durch Drag and Drop eines verbunden Pfeiles auf eine leere Stelle auf dem
     DrawingBoard, kann eine Verbindung getrennt werden. Wird sie auf eine
     anderen Input gedropt, so wird diese als neues Ziel gesetzt und die 
     Verbindung zur vorherigen Funktionseinheit gelöscht. TODO
     

**** MISSING IMAGES Erstellen von Integrationen
     Durch Rechtsklick auf eine Funktionseinheit kann im Kontextmenu der Eintrag
     'Make to Integration of (Pick)' ausgewählt werden. Der Cursor verändert
     sich und wird nun eine andere Funktionseinheit angeklickt, so wird der
     komplette Flow, in der diese Funktionseinheit Teil ist, als zu
     Sub-Flow der Integration genommen.

     Das Entfernen eines Flows von einer Integration geschieht indem auf eine
     Funktonseinheit rechtsklickt und dann auf 'Remove from Integration'
     ausgewählt wird. Der komplette zusammenhängede Flow wird dann aus der
     Integration entfernt. 


     Bei einer Modifikation des Datenflusses innerhalb einer Integration, werden nach
     bestimmten Regeln die nachfolgenden (abgetrennten) Funktionseinheiten
     ebenfalls aus der Integration entfernt. Wird die erste Funktionseinheit
     entfernt, gilt diese Regel nicht.

**** Definieren von Datentypen
     Eigene DatenTypen können auf der rechten Seite des Editors angelegt werden.
     Durch Rechtsklick -> Add New DataType. Außerdem zeigt der obere Button an,
     ob im akutellen Diagramm Datenflüsse mit Daten fließen, die nicht definiert
     sind. ( int, string, double, usw. werden automatisch ignoriert). Ein Klick
     auf diesen erstellt für jeden nicht-definierten Datentyp ein neuen Eintrag.
     Auch Datentypen innerhalb eines eigenen Datentypen werden überprüft, ob sie 
     bekannt sind oder nicht. Bsp. 
     Person 
     name:string
     address:Address  

     Der Editor würde überprüfen ob der Address Datentyp definiert wurde oder nicht.

**** MISSING IMAGES Navigation und Shortcuts
     Zur Navigation innerhalb des DrawingBoards wird das Mausrad verwendet.
     Durch Scrollen wird in das DrawingBoard herein und herausgezoomt.
     Durch gedrückthalten des Mausrades (mittlere Maustaste) und Bewegen der
     Maus kann die Ansicht verschoben werden ( das DrawingBoard ist endlos groß)
     
     Ein weiteres Feature besteht darin, dass ab bestimmten Zoom-Stufen die
     Font-Größen der Namen der Funktionseinheiten angepasst werden und die 
     Textfelder der Datenflüsse ausgeblendet werden.
     Außerdem können Textfelder nicht mehr fokusiert werden, was ein einfachers
     Verschieben der Funktionseinheiten ermöglichen soll. Diese Eigenschaft wird
     visuell erkenntlich gemacht, dass die Hintergrundfarbe des Textfeldes bei
     einer selektierten Funktionseinheit nicht mehr dunkel ist.
     Auch der Mousecursor zeigt bei einem Mouse-Over an, dass man nicht mehr in
     das Textfeld klicken kann.


**** Weitere Features
     - Speichern, Laden, Mergen.
       Speichern und Laden in 3 Dateiformate werden unterstüzt.
        (yaml, json und xml - nach Dateigröße aufsteigend sortiert)
        Auch das Laden eines anderen Flow Design in das akutelle geladene wird 
        mit der Merge-Funktion unterstützt.
     

     - Unhandled Exception ErrorDialog
       Wird eine Exception geworfen, die nicht behandelt wurde, so wurde eine
       allgemeine Fehlerbehandlung aufgerufen. Das Programm stürzt nicht ab,
       sondern ein Dialog errscheint, mit einem Stacktrace und Informationen
       über die geflogenen Exception. Der Benutzer kann das entscheiden, ob er
       hier das Programm Beenden will, oder weiter den Fehler ignorieren will.
       Der Stacktrace kann gegenenfalls kopiert und an den Entwickler als
       Bugreport zuschicken werden.

     
     - Help-Window
       Ein kleines einfaches Fenster gibt dem Benutzer einen Überblick über die
       vorhandenen Shortcuts und die Navigation mit der Maus wird erklärt.


     

*** Views / ViewModels
    Das Projekt wurde nicht strikt nach MVVM-Regeln (Model-View-ViewModel) 
    umgesetzt, jedoch bedient es sich der Idee, das es eine View gibt, die
    als Datenkontext ein ViewModel zugewiesen hat. Das zuweisen eines
    Datenkontextes erlaubt es Elemente der View an Properties des ViewModels zu
    binden. Ein Binding bewirkt, dass sich die UI-Element automatisch updatet,
    sobald sich das dazugehörige Property ändert. Eine Änderung einer
    Eigenschaft des ViewModels ändert also automatisch die View.
 
    Die GUI besteht aus mehreren Views (xaml-Dateien) und dazugehörigen ViewModels.
    Die Aufgabe des ViewModels besteht vorallem darin, ein Model entgegenzunehmen und dieses
    darzustellen, bzw. die aktuelle Darstellung zu aktualisieren.
    
    Nach jeder Änderung am Model - zum Beispiel das Hinzufügen einer neuen
    Node -  dieses komplet neu zu laden (Löschen und neu Hinzufügen aller
    ViewModels, die wiederum ein neu Generieren der UI-Framework-Elemente zur
    Folge hatte) erwies sich als nicht sehr performant. 
    Ab Diagrammen, mit über 20 Nodes, stieg die Zeit zur Aktualisierung der View
    bereits auf mehrere Sekunden an.
    Die Lösung bestand darin, nicht einfach stur alles zu Löschen und neu
    hinzuzufügen, sondern darin, die Änderungen am Model zu lokalisieren und nur
    diese neu zu erstellen, bzw nur die Properties neu zu setzen. Durch
    diese Verbesserungen wurde die Performance deutlich gesteigert, sodass
    Diagramme mit mehrern hundert Nodes keine spürbaren Perfomanceverluste mit
    sich führt. Einzig das Duplizieren von vielen Nodes dauert nach wie vor
    mehrere Sekunden. 

*** Interaktionen
    Wie bereits in Kapitel 2 (Abschnitt Entwurfsmethode) schlägt Flow Design
    vor, alle Events als Interaktionen zu bezeichnen und für jedes dieser
    Änderungen ein eigenen Flow Design zu erstellen. 
    Es bietet sich somit an, alle Interaktionen in einer Klasse zu sammeln.
    Diese bietet somit eine Überblick über alle Funktionalitäten der GUI.
    Da diese Integrationen sind, sind sie leicht zu verstehen (mit Ausnahmen). Die
    Interaktionen rufen Methoden von anderen Klassen auf, die die Operationen am
    Mainmodel vereinfachen. Am Ende fast jeder Interaktion wird die =ViewRedraw=
    Methode aufgerufen, die das =MainViewModel= veranlasst, das Model neu zu
    laden und somit die Änderungen der Interaktion in der GUI sichtbar macht.
    Deshalb erwies es sich als schlecht, wenn eine Interaktion eine andere
    Interaktion aufruft, um ihre Funktionalität umzusetzen. 
    Stattdessen war es eine bessere Lösung, den Code der einen Interaktion in
    die andere zu Kopieren. Dies wiederspricht zwar dem DRY Prinzip, jedoch eine
    Coderedundanz innerhalb von Integrationen stellt sich als nicht sehr schlimm
    heraus. Integrationen beinhalten schließlich keine Logik (Fussnote: Beim
    Aufruf einer Funktionseinheit, die mehrere Outputs liefert, existiert
    eigentlich auch eine Logik in der Integration ( Bsp: IsIntegration: Wenn ja,
    dann X wenn nicht, dann Y. Dadurch verlieren Integrationen etwas ihre
    Leichtgewichtigkeit und sind nicht mehr ganz so einfach zu verstehen ) und haben eine hohe
    Abstraktion.
    
    Beispiel dieser Aussage:
#+BEGIN_SRC cpp

        public static object AppendNewFunctionUnit(FunctionUnit currentFunctionUnit, double offsetX, DataStreamDefinition outputToConnect, MainModel mainModel)
        {
            var newFunctionUnit = FunctionUnitManager.CreateNew();

            newFunctionUnit.Position = currentFunctionUnit.Position;
            newFunctionUnit.MoveX(offsetX);

            // default IO of new function unit: input of new function unit = output to connect to of current function unit
            newFunctionUnit.InputStreams.Add(DataStreamManager.NewDefinition(newFunctionUnit, outputToConnect));
            newFunctionUnit.OutputStreams.Add(DataStreamManager.NewDefinition(newFunctionUnit, "()"));
            MainModelManager.ConnectTwoDefintions(outputToConnect, newFunctionUnit.InputStreams.First(), mainModel);

            mainModel.FunctionUnits.Add(newFunctionUnit);

            ViewRedraw();

            return newFunctionUnit;
        }

        public static FunctionUnit CreateNewOrGetFirstIntegrated(FunctionUnit currentFunctionUnit, MainModel mainModel)
        {
            FunctionUnit @return = null;

            currentFunctionUnit.IsIntegration(
                isIntegration: () => @return = currentFunctionUnit.IsIntegrating.First(),
                isNotIntegration: () =>
                {
                    var newFunctionUnit = FunctionUnitManager.CreateNew();
                    newFunctionUnit.Position = currentFunctionUnit.Position;
                    newFunctionUnit.MoveY(100);

                    newFunctionUnit.InputStreams.Add(DataStreamManager.NewDefinition(newFunctionUnit, currentFunctionUnit.InputStreams.First()));
                    newFunctionUnit.OutputStreams.Add(DataStreamManager.NewDefinition(newFunctionUnit, "()"));

                    currentFunctionUnit.IsIntegrating.Add(newFunctionUnit);

                    mainModel.FunctionUnits.Add(newFunctionUnit);

                    @return = newFunctionUnit;
                    ViewRedraw();
                });

            return @return;
        }
  
#+END_SRC

     
 
**** MISSING IMAGES Auswirkungen der beiden Interaktionen (Listing Caption)
     Die =AppendNewCell= Methode erzeugt eine neue SoftwareCell und und
     verschiebt diese entlang der X Postion.
     Außerdem setzt sie den Input gleich der DataStreamDefinition die
     übergebenen wurde und verbindet diese beiden.
     =AppendNewCell= wird durch die Tastenkombination Ctrl-Tab ausgelöst, wenn
     sich der Tastaturfokus innerhalb eines Textfeldes einer View einer Softwarecell oder
     DatastreamDefinition befindet. Bei ersterem wird der erste unverbunden Output als der
     DataStreamDefinition genommen, andem die neue SoftwareCell angehängt wird (
     nicht Teil dieser Methode).

     Beide Methoden geben eine
     Model-Instanz als =object= an die GUI zurück. Die GUI-Logik findet dann die
     dazugehörige View und setzt den Focus darauf.

**** Coderedundanzen 
     Beide Methoden sind Methoden aus der Interaktions-Klasse, sind werden also
     direkt aus einem Event von der GUI ausgelöst. 
     Beide Methoden haben ähnliche Methodenaufrufe ( Neue Funktionseinheit
     erzeugen, sie auf die gleiche Position zu setzten wie die der übergebenen
     Funktionseinheit, neue Default-Werte für den Output-Stream der neuen
     Funktionseinheit setzen, dem MainModel die neue Funktionseinheit zu geben
     und die Ansicht neu zu zeichnen). Diese könnten in eine neue
     Integration ausgelagert werden, hätte jedoch eine unnötige
     Verschachtelung von Code als Auswirkung. Besser ist es hier die
     Coderedundanz als etwas nicht schlimmes anzusehen und diese zu belassen.
     So ist auf einen Blick ersichtlich, was die Interaktion genau macht, ohne
     im Code herumspringen zu müssen.

*** Eigene Tabstop-Logik
    Mit Tab und Shift-Tab soll es dem Nutzer möglich sein den Tastaturfokus zu
    verändern. Dieses Beispiel zeigt dabei noch einmal, das Coderedundanzen innerhalb
    von mehreren Integrationen nichts Schlechtes sein muss.
    Außerdem macht es auch deutlich, wie eine etwas komplexerer Integration mit
    mehreren verschachteteln Lambda-Ausdrücken in der Praxis aussehen kann.
    Auch das Arbeiten mit dem Model und Managerklassen soll
    dieses Beispiel dem Leser verdeutlichen.


    Der nächsten Tabstop soll nach folgenden Regeln und abhängig vom aktuell
    fokusierten Model bestimmt werden:

***** MISSING IMAGES FunctionUnit
      Besitzt akutell die View einer FunctionUnit den Tastaturfokus, so soll als
      nächste Stop der erste Datenfluss, der verbunden ist gewählt werden. Ist keiner
      verbunden, wähle als nächsten Tabstop den ersten Output.

***** MISSING IMAGES DataStream
      Der sehr einfache Fall trifft ein, wenn der Fokus aktuell auf einem
      DataStream liegt. Der nächste Stop ist dnn die Ziel-Funktionseinheit des Datenflusses

***** MISSING IMAGES DataStreamDefinition
      Der komplexeste Fall: 
      Zu erst muss überprüft werden, ob es sich um ein Input oder Output
      handelt. Ist es ein Input, so soll als nächster Stop die Funktionseinheit
      selbst zurückgegeben werden, von der die DataStreamDefinition der Input ist. 
      Bei einem Output muss überprüft werden, ob das Ende des Flows erreicht
      wurde, oder nicht. Wird ein verbundener Output entdeckt, wird der
      entsprechende DataStream als nächster Stop zurückgegeben. Ist das Ende
      erreicht, so soll zum Anfang des kompletten Flows gesprungen werden.

#+BEGIN_SRC cpp

public static object TabStopGetNext(object focusedModel, MainModel mainModel)
        {
            object @return = null;

            focusedModel.TryCast<FunctionUnit>(fu =>
            {
                // prefer connected outputs as next tabstop
                // if no connected take first output defintion if there are any
                fu.OutputStreams.GetFirstConnected(
                    foundConnected: connectedDsd => 
                        @return = MainModelManager.FindDataStream(connectedDsd, mainModel),
                    noConnected: () => 
                        @return = fu.OutputStreams.FirstOrDefault());
            });

            focusedModel.TryCast<DataStream>(stream =>
            {
                // if focus was inside datastream take its destination function unit as next tabstop
                if (stream.Destinations.Any())
                    @return = stream.Destinations.First().Parent;
            });

            focusedModel.TryCast<DataStreamDefinition>(dsd =>
            {
                // if focus was inside definition there are two case:
                // is input definition: next tabstop is the function unit of the definition
                // is output definition: in case the end of the flow was reached ( no connected output ) 
                // the next tabstop is the first input definition of the beginning of the whole flow.
                // Is the end not reached go to first connected output datastream
                dsd.CheckIsInputOrOutput( 
                    isInput: () => @return = dsd.Parent,
                    isOutput: () =>
                    {
                        dsd.Parent.OutputStreams.GetFirstConnected(
                            foundConnected: connectedInput => 
                                @return = MainModelManager.FindDataStream(connectedInput, mainModel),
                            noConnected: () => // loop tabstop focus when the end is reached
                                @return = MainModelManager.GetBeginningOfFlow(dsd.Parent, mainModel)); 
                    });
            });
            return @return;
        }
#+END_SRC

    Analog dazu die Tabstop-Methode in die entgegengesetzte Richtung.


#+BEGIN_SRC cpp
        public static object TabStopGetPrevious(object focusedModel, MainModel mainModel)
        {
            object @return = null;

            focusedModel.TryCast<FunctionUnit>(fu => 
            {
                fu.InputStreams.GetFirstConnected(
                    foundConnected: connectedDsd => 
                        @return = MainModelManager.FindDataStream(connectedDsd, mainModel),
                    noConnected: () =>
                        @return = fu.InputStreams.FirstOrDefault());
            });

            focusedModel.TryCast<DataStream>(stream => 
            {
                if (stream.Sources.Any())
                    @return = stream.Sources.First().Parent;
            });

            focusedModel.TryCast<DataStreamDefinition>(dsd => 
            {
                dsd.CheckIsInputOrOutput(
                    isOutput: () => @return = dsd.Parent,
                    isInput: () => 
                    {
                        dsd.Parent.InputStreams.GetFirstConnected(
                            foundConnected: connectedInput =>
                                @return = MainModelManager.FindDataStream(connectedInput, mainModel),
                            noConnected: () => // loop tabstop focus when the beginning is reached
                                @return = MainModelManager.GetEndOfFlow(dsd.Parent, mainModel));
                    });
            });

            return @return;
        }
        


#+END_SRC


**** Erläuterung
     Auf oberster Ebene wird überprüft um welchen Typ von Objekt es sich
     handelt, der aktuell fokusiert ist (Fussnote: Teile davon war Aufgabe der UI und die
     Interaktion bekommt das Model dann als =object= übergeben. Deshalb bedarf es
     innerhalb der Methode einer Überprüfung des Typen mit TryCast). Nun
     existieren die drei Fälle, abhängig vom übergebenen Typen.

      Beachte: Die Sources-Eigenschaft eines DataStream beinhaltet nicht die Funktionseinheit,
      sondern die DataStreamDefinition einer Funktionseinheit. Die eigentliche
      Funktionseinheit enthält die Parent-Eigenschaft der DataStreamDefinition.
      Analog dazu enthält die InputStream- und OutputStream-Eigenschaft der
      FunctionUnit auch nur die DataStreamDefinitionen nicht ein DataStream-Objekt.
      Eine DataStreamDefinition kennt jedoch nicht den Datenfluss, mit dem sie
      verbunden ist. Eine Helfer-Methode der MainModelManager-Klasse stellt
      diese Funktionalität zum Auffinden des DataStream zur Verfügung.


** Roslyn - Generierung von Code aus einem Diagramm
*** Vorstellung Roslyn
**** Erzeugung Datentypen als einfaches Beispiel
*** Erzeugung von Methodensignaturen
**** Datentypen 
**** DatanameParser
*** Erzeugung der Integration-Bodies 

** Generierung eines Diagrammes aus Code
