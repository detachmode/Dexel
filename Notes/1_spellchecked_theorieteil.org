
*  Entstehung und Grundgedanken

** DRAFT Einleitung

Flow Design ist aus der Clean Code Development Bewegung heraus entstanden. Hauptinitiatior und Erfinder ist Ralf Westphal.
Ralf Westphal war auch Mitbegründer und Miterfinder der Clean Code Developement Bewegung.


Clean Code Development ist eine Ansammlung aus Prinzipien, die einem helfen
sollen wartbare Software zu schreiben. Ein Synonym, welches CCD für wartbar
verwendet lautet /evolvierbar/.
Software die mit dem Fokus auf Evolvierbarkeit hin programmiert wurde,
kann leicht an neue Rahmenbedingungen oder Kundenwünsche angepasst werden.
Gleichzeitig soll der Code auch leserlich bleiben und möglichst ohne Kommentare
verstanden werden können.

Prinzipien sind jedoch nicht so leicht einzuhalten, wie konkrete Regeln, welche man einfach einhalten kann.
Somit ist es in der Praxis schwer die Prinzipien auf den eigenen Code anzuwenden.
Flow Design soll in Ergänzung eine Methodik und Programmierregeln bieten, die man einfach befolgen kann und man erhält automatisch
ein Code, der die CCD Prinzipien erfüllt.

** FRAGEN CCD Prinzipien
Im Hauptfokus von Flow Design liegen vor allem folgende Prinzipien von CCD:

  | KISS (Keep It Stupid Simple)      | Ein System sollte so einfach wie möglich gestaltet werden.                                                                                                         |
  | YAGNI ( You Ain't Gonna Need It ) | Es soll nicht unnötig viel Zeit damit verbracht werden für zukünftige Eventualitäten zu programmieren. Der Fokus sollte darauf liegen, was aktuell gebraucht wird. |
  | Lose Koppelung                    | Separate Einheiten eines Systems sollen möglichst über möglichst wenige Punkte miteinander kommunizieren.                                                          |
  | Orthogonalität                    | Änderungen an einer Funktion des Systems sollen auf so wenig wie möglich andere Funktionen des Systems negativen Einfluss haben.                                   |

FRAGE: Kurzbeschreibung richtig?

*** KISS
Die Komplexität der Lösung eines Problems soll immer in Relation zu der
Komplexität des Problems stehen.

Schnell passiert es, dass man die einfachste Lösung für ein Problem übersieht und das Problem unnötig verkompliziert.
Das KISS Prinzip soll einen in erster Linie ein Bewusstsein dafür schaffen bei
komplizierten Lösungen innezuhalten und sich nochmal genau zu
überlegen, ob es nicht eine einfachere Lösung gibt.
Manche Problemdomänen erfordern jedoch eine komplexe Lösung, da das Problem
komplex ist.

Verkomplizierte Lösungen müssen am besten schon beim Entwurf erkannt werden.
Hierbei soll Flow Design als Entwurfsmethode helfen, die einfachste und leicht
verständlichste Lösung für ein Problem zu finden.

*** YAGNI
Vielen Programmieren ist es wohl schon passiert, dass sie es zu gut gemeint
haben mit dem vorausschauend Denken. Etliche Funktionen wurden für ein
zukünftiges Szenario implementiert oder verkompliziert, die jedoch nie
eintrafen, oder falls sie eintrafen wurde die Software bereits durch eine
andere ersetzt.
YAGNI soll einem das Bewusstsein dafür schärfen, wann man sich gerade mit einer
Situation beschäftigt, die aktuellen Rahmenbedingungen überschreiten.
Man sollte sich eher auf das aktuelle Szenario beschränken  und keine unnötige Ressourcen für zukünftige
Eventualitäten verschwenden.
Flow Design bietet hierfür Implementierungsregeln, die es einem ermöglichen
schnell Änderungen am Code zu realisieren.
Diese Eigenschaft des Codes bietet damit die Basis diesem Prinzip auch getrost
zu befolgen und sich auf die aktuellen Rahmenbedingungen zu konzentrieren.

*** Lose Koppelung
Ein System soll aus möglichst voneinander unabhängigen Untersystemen bestehen,
die nur über eine  klar definierte Stelle miteinander kommunizieren.
Bei jedem Aufruf einer Funktion oder Abrufen einer Variable entsteht eine
Koppelung zwischen beiden.
Ändert sich die Struktur des Codes, so muss jede Stelle angepasst werden, die zu
der geänderten Struktur eine Koppelung besitzt. Mit loser Koppelung möchte man
veranschaulichen, dass wenn eine Koppelung nötig ist, diese an einer Stelle konzentriert sein soll und
sich nicht an verschiedenen Stellen des Codes fortpflanzen soll.

*** Orthogonalität
In einem dreidimensionalen Raum sind die 3 Achsen üblicherweise zueinander
orthogonal. Verschiebe ich ein Objekt auf einer Achse, so bleiben die Werte der
beiden anderen unberührt Wäre eine Achse nicht orthogonal zu den beiden anderen,
so würde eine Verschiebung entlang dieser Achse auch eine Änderung der Werte
einer anderen Achse bewirken. Diese Eigenschaft wird nun auch auf Code und wie
er auf Änderungen reagiert, projiziert
Wird an einer Stelle der Code geändert, soll diese Änderung möglichst keinen Einfluss auf
andere Teile des Codes haben.


** DRAFT Weitere Prinzipien die Beachtung finden sollen

| DRY  (Don't Repeat Yourself)    | Coderedundanzen vermeiden, zerlegen in Codebestandteile, die man an mehreren Stellen wiederverwenden kann                                                                                      |
| kleine Funktionen               | Viele kleine Funktionen , anstatt eine große Funktion                                                                                                                                          |
| Single Responsibility Principle | Jede Funktion/Klasse soll sich nur um eine Sache kümmern. Falls eine Funktion mehrere Aufgaben erledigt, sollten sie diese nicht selbst implementieren, sondern an Unterfunktionen weitergeben |
| Separation of Concerns          | Unterschiedliche Funktionalitäten des System sollen in unabhängige Untersysteme gekapselt sein.                                                                                                |
| Information Hiding Principle    | Ein Untersystem soll seiner Inneren Funktionalität vor anderen Systemen verbergen und eine möglichst fokussierte Schnittstelle bieten, mit dem äußere Systeme dieses System steuern können.      |
| Dependency Injection           | Objekte/Variablen werden einer Funktion als Parameter mitgegeben, anstatt eine Bindung an einen äußeren Variable zu erzeugen.                                                              |

*** DRY
Einer der wichtigsten Aspekte von sauberen Codebasen. Der Grund warum es
überhaupt Programmstrukturen wie Funktionen, Methoden, Klassen etc. gibt.
Durch Coderedundanzen (Copy-Paste) können schnell Fehler entstehen, der Code
wird unverständlicher und durch die Wiederholungen schwerer zu lesen.
Wenn man das DRY Prinzip befolgt, können viele Änderungen meistens bereits an
eine Stelle gezielt geändert werden, anstatt die Änderung an vielen Stellen
machen zu müssen.

*** kleine Funktionen
Nachteile
- Der Programmverlauf ist bis ins Detail nicht mehr so leicht zu überschauen
- In bestimmten Szenarien ist der Overhead eines Methodenaufrufs möglicherweise
  ein nicht zu verachtender Performanceaspekt (Remote Procedure Calls)
Vorteile
- Erspart Kommentare durch aussagekräftige Methodennamen
- Änderungen sind leichter zu realisieren, da durch kleine Methoden auch die
  höhere Wiederverwendbarkeit einzelner Methoden gegeben ist. Durch weniger Redundanzen kann man
  eine Änderung meistens gezielt an einer Stelle machen anstatt an vielen
  Stellen etwas ändern zu müssen.
- Erlaubt ein Denken auf höherer Abstraktionsebene, da low-Level
  Implementierungsdetails hinter aussagekräftigen Methodennamen verborgen sind.
- Erlaubt anderen Personen den Code leichter zu verstehen und  können selbst
  leichter Änderungen an der Codebasis realisieren, da sie nicht den kompletten
  Code nachvollziehen brauchen, sondern direkt zu den für sie relevanten Stellen
  springen können.
- Automatische Test / Unittest sind besser realisierbar, da man feingranularer
  Testen kann

*** TODO Single Responsibiltiy Principle
Beispiel einer Methode, die mehrere Verantwortlichkeiten hat:

Sauber getrennte Verantwortlichkeiten:
*** Separation of Concerns
Wenn man mit Single Responsibility Principle die Methoden in viele kleine
Methoden aufgeteilt hat, so ist es ratsam, solche in Container
zusammenzufassen, die einen ähnlichen Aufgabenbereich haben.
Als Container können zum Beispiel Klassen verwendet werden.
Oft meint man mit Separation of Concerns auch das Trennen von
GUI, Daten und Businesslogik gemeint.

*** Information Hiding Principle
Eine Klasse besteht aus vielen Funktionen, diese werden jedoch nicht alle nach
außen zur Verfügung gestellt.
Oder eine API, die nach außen nur eine ganz bestimmte Schnittstelle bietet und
die Komplexität des Systems im Inneren verbergt.

*** Dependency Injection
Anstatt das eine Methode auf eine äußere Variable (zum Beispiel eine Membervariable einer
Klasse) zugreift, bekommt sie den Wert als Parameter mit.
Durch erhält man Methoden, die leichter mit Mockdaten zu testen sind.




** DRAFT Flow Design - Was ist das?

Unter Flow Design versteht man zwei Dinge:
Einmal das Diagramm und einmal die komplette Entwurfsmethode, indem das
Diagramm nur ein Teil davon ist.

Flow Design soll im Gegensatz zu UML besser geeignet sein, bereits in der Entwurfsphase Anwendung zu finden.
Ziel ist es sich auf dem Papier bereits ein Entwurf der Programmstruktur überlegen zu können.
Aktuell sei es aus der Mode gekommen, vor dem Programmieren einen Entwurf zu erzeugen, was vor allem daran läge, dass die vorhandenen
Entwurfsmethodiken eher hinderlich seien und einen unnötigen Overhead erzeugen ( laut Ralf Westphal)
Es sei somit üblich geworden die Denkarbeit, wie man seinen Code möglichst sauber strukturieren kann,
während dem Programmieren direkt im/vor dem Sourcecode zu verrichten.
Dies sei jedoch laut Ralf Westphal eine eher ungünstige Lösung und behindere eher den kreativen Denkprozess mit
unnötiger Schreibarbeit.
Auf dem Papier sei man mit einer passenden Entwurfsmethodik schneller und man könne auch verschiedene Ideen schneller
ausprobieren, Änderungen machen, oder auch wieder verwerfen, als direkt im Sourcecode.

Es geht jedoch nicht darum den Sourcecode bis ins kleinste Detail in eine Art visuelle Programmiersprache zu pressen,
sondern darum, wie man den Code am sinnvollsten in Funktionseinheiten zerlegt (die einen möglichst aussagekräftigen Namen haben sollten).
Wie die Funktionalität auf unterster Ebene implementiert wird, wird auf dem Diagramm nicht berücksichtigt.
Das ist jedoch keine negative Einschränkung, vielmehr ermöglicht dies, sich auf beim Entwurf nicht mit unnötigen Implementierungsdetails beschäftigen zu
müssen, sondern sich auf das Große ganze - das Zusammenspiel/ Komposition der Funktionseinheiten und den Datenfluss zu konzentrieren.

Anzumerken wäre noch, dass nicht der Kontrollfluss abgebildet wird, sondern, wie erwähnt, der Datenfluss.
** Referenzen

http://clean-code-developer.de/die-grade/roter-grad/

* Pfeile und Kreise
** DRAFT RomanNumbers Beispiel

[[./img/FromRomanNumerals.png]]

Das nachfolgende Beispiel soll an einem einfach Beispiel zeigen, was ein Flow Design Diagramm ist.
Das Programm/Unterprogramm soll eine römische Zahl in eine Dezimalzahl konvertieren.

Alle eingekreisten Namen sind Funktionseinheiten, oder auch Softwarezelle genannt.
Diese werden in den meisten Fällen im Code als Methoden implementiert.
Die Pfeile zeigen den Datenstrom. Links die Inputs und rechts die Outputs.


Der Input-Datenstrom besteht aus einem String. Dieser String wird zerlegt in einzelne Buchstaben.
Der Buchstabenstrom wird anschließend einer Funktionseinheit gegeben, die jeden Buchstaben zu der entsprechenden
Dezimalzahl konvertiert. Anschließend muss auf den Strom noch nach eine Negationsregel angewandt werden. Diese untersucht den
Strom aus Ganzzahlen auf Stellen, wo eine kleinere Zahl vor einer größeren Zahl steht und sie in dem Fall dann negativ macht.
Am Ende wird der Datenstrom einer Funktionseinheit übergeben, die alle Zahlen aufaddiert.
Das Ergebnis ist die Summe aller Zahlen.

Die Funktionseinheiten sind im Diagramm als Kreise dargestellt, in welchen der möglichst aussagekräftige Name steht.
Pfeile zeigen den Datenstrom, auf dem der Datentyp vermerkt ist.
Links gehen Pfeile in die Funktionseinheit hinein, das ist der eingehende Datenstrom und rechts ist der ausgehende Datenstrom.
Die Funktionseinheit wird auch als Domäne bezeichnet. Die Domäne interessiert sich nur für ihre Aufgabe und soll möglichst isoliert
betrachtet ihre Aufgabe erledigen können.
** MISSING IMAGES Hierarchische Datenflüsse
Das Flow Design unterstützt die Funktion in eine Softwarezelle sozusagen hineinzuzoomen.
Hier erkennt man die rekursive Eigenschaft der Softwarezellen. Eine Softwarezelle kann wiederum aus mehreren Softwarezellen bestehen,
die zusammen die Aufgabe erledigen, die die übergeordnete Softwarezelle beschreibt.


* Notationen
** MISSING IMAGES Datentypen

Eine leere Klammer bedeutet, dass keine Daten fließen.
Falls man sowohl dem Datenstrom einen Namen geben möchte, als auch den Datentyp definieren möchte, schreibt man beides mit einem
Doppelpunkt getrennt hintereinander.
** MISSING IMAGES Definition eigener Datentypen
Benutzt man einen Datenstrom bestehend aus einem eigenen Datentypen, so zeichnet man irgendwo auf dem Papier eine Box,
indem man den Datentyp mit seinen Membervariablen auflistet.

** MISSING IMAGES Arrays (auch mit fester Größe)
Werden Daten als Arrays mit fester Größe übergeben, so wird hinter dem Datentyp eine leere eckige Klammer angehängt.
Ist die Arraygröße bekannt, so kann man diese in die Klammer noch zusätzlich eintragen.
** FRAGEN 0 bis n (Datenstrom)

[[./img/diagram0n.png]]

Wird als * außerhalb der Klammer dargestellt.
(int)*
Selten wird ein Datenstrom auch mit geschweiften Klammern dargestellt, um ihn von dem optionalen Output zu unterscheiden.
{int}

FRAGE: Wenn auf Container mit yield gearbeitet wird, so sind die Grenzen zum
Datenstrom verschwommen.
** FRAGEN Container / Listen

[[./img/diagramCollection.png]]

Stern innerhalb der Klammer.
Der Datentyp liegt in einem Container vor.
Die zu bearbeitende Daten können entweder komplett auf einmal an die Funktionseinheit gegeben werden ( als Liste, Dictionary, etc. )
oder aber - falls die Programmiersprache dies unterstützt - als yield ähnlich
wie ein Stream realisiert werden, wo einzelne Elemente bereits abgearbeitet werden
können, bevor alle anderen Daten erzeugt wurden.

** FRAGEN 0 bis 1 (optionaler Output)

[[./img/diagramOptional.png]]

Eckige Klammer
[int]

Optionale Outputs können nicht über ein Rückgabewert realisiert werden.

FRAGE: Stimmt das? Kann man nicht auch ein Datentyp verwenden, der =null= Werte zulässt?
Dann müsste jedoch wahrscheinlich die folgende Operation den Input auf null überprüfen.

** MISSING IMAGES Mehrere Inputs / Outputs auf einem Weg
Mehrere Inputs werden in die Klammer geschrieben und mit einem Komma getrennt.

Mehrere Outputs lassen sich nicht in allen Sprachen einfach realisieren
Wahlweise kann man es mit Tupel realisieren, oder man verwendet stattdessen
einen eigenen Datentyp, der alle Output-Daten beinhaltet.

** DONE Joined Inputs
CLOSED: [2016-09-08 Do 13:43]

[[./img/diagramJoin.png]]

Wenn die Softwarezelle nur dann ihre Aufgabe erledigen kann, wenn mehrere ihre Inputs
vorhanden sind und diese aus unterschiedliche Quellen stammen, dann braucht man ein so genannten Join.
Dieser wird als Linie dargestellt an die mehrere Inputs zusammenlaufen.

Im Code kann dies einfach realisiert werden als eine Funktion, die mehrere Inputparameter entgegennimmt.

Das Bündeln der Datenströme soll nicht die Funktion F erledigen, sondern ist Aufgabe einer übergeordneten Funktionseinheit.
Die Funktionseinheit F erwartet einfach 2 Parameter auf einmal und kennt deren Herkunft nicht.

** FRAGEN Tonnen

[[./img/diagramTonne.png]]
Hat die Funkton keine Eingangsparameter, so hat sie oft stattdessen eine Tonne, die anzeigt, dass die Funktionseinheit state-behaftet ist.

Tonnen bedeuten, dass die Funktionseinheit state-behaftet ist.
In den meisten Fällen ist das eine Membervariable einer Klasse?

FRAGE: Kann State auch anders umgesetzt sein?
** FRAGEN Abhängigkeiten / Provider

Tonnen oder Dreiecke können zusätzlich noch mit einer Linie verbunden sein, an dessen Ende ein Kreis gezeichnet ist,
dann bedeutet das, dass die Funktion auf externe Ressourcen zugreift / von ihr
Abhängig ist.
Den Kreis kann man sich bildlich wie eine Hand vorstellen, an die sich die
Funktion festhält, also eine Koppelung entsteht.
FRAGE: Was bedeutet nochmal genau dir Hand?

** MISSING IMAGES GUIS / Programmstart/ Ende
Programmstart wird mit einem Kreis leeren Kreis dargestellt und Programmende mit
einem Kreis in dessen Mitte ein Kreuz ist.
Wenn man zeigen will, dass eine Methode von einem Event aus der GUI ausgelöst
wurde, so macht man das deutlich, indem man ein Viereck links von der Methode zeichnet.
** DRAFT Klassen / Container definieren
Das Definieren von Container und Zuordnen von Funktionseinheiten ist auch
einfach möglich. Unter Container versteht man: Klassen, DLLs und Anwendungen.
Es gibt zwei Möglichkeiten eine Zugehörigkeit zu einem Container zu notieren.
Entweder man schreibt direkt unter der Funktionseinheit den Namen des
Containers, oder man umrandet mehrere Funktionseinheiten und notiert den Namen
des Containers am Rand der Umrandung.
** Referenzen
Bilder sind von:
http://flow-design.org/overview/implementation/#How_to_implement_inputs_to_a_functional_unit

* Implementation

Regeln:
- Trennen von Integrationen und Operationen
- keine funktionale Abhängigkeiten in Operationen zu anderen Funktionseinheiten aus dem selben Programm
** IODA Architektur
IODA steht für: Integration Operation Data API
 #+CAPTION: http://blog.ralfw.de/2015/04/die-ioda-architektur.html
[[./img/ioda1.png]]

*** DRAFT Erläuterung des Schaubildes
Das Flow Design unterscheidet zwei Arten von Funktionseinheiten: Integrationen und Operationen.
Die Aufgabe einer Integration ist, die unabhängigen Operationen in das große Ganze zu
Integrieren.
(Fußnote) Ralf Westphal spielte auch mit den Gedanken diese als Funktionseinheiten als Koordinatoren oder
Kompositionen zu bezeichnen.

Integrationen "integrieren" andere Integrationen und/oder Operationen in das Programm. Sie dürfen also funktional abhängig sein
von beiden Arten von Funktionseinheiten.

Im Gegensatz dazu dürfen Operationen keine Integrationen oder andere Operationen kennen.
Sie dürfen aber auf Daten Zugreifen über diese entsteht auch die einzige Möglichkeit der Kommunikation zwischen Operationen.
Mit Daten sind meint man sowohl inpersitent Daten (Daten im Arbeitsspeicher), als auch persitente Daten auf der Festplatte.
Wie zum Beispiel Dateien, oder Datenbanken, wobei man beides auch zu der Gruppe API zählen könnte.
Außerdem werden API-Aufrufe in Operationen isoliert und eine Integration darf kein Wissen über die API haben.

Sowohl Operationen als auch Integrationen dürfen Daten Erzeugen.
Beispielsweise das Aufrufen eines Konstruktors oder Deklarieren einer lokalen Variablen.
Das Koordinieren und Weiterreichen und von Daten übernimmt jedoch die Integrationen ( was auf dem Schaubild nicht so
gut herauskommt).

Anhand einer Flow Design Skizze, kann man leicht herausfinden, welche Methoden Operationen sind und welche
Integrationen.
Alle Leaf-Knoten sind Operationen, der Rest sind Integrationen.



*** DRAFT PoMO ( Principle of Mutual Oblivion)
#+BEGIN_QUOTE
    Ein Producer kennt seinen Consumer nicht. Ein Consumer kennt seinen Producer
    nicht. Das nenne ich das Principle of Mutual Oblivion (PoMO,
    Prinzip der gegenseitigen Nichtbeachtung) -- architect napkin, Seite 80
#+END_QUOTE

Dieses Prinzip besagt, dass Funktionseinheiten sich nicht gegenseitig kennen sollen.
Es soll auch verhindert werden, dass eine Einheit eine andere aufruft und von deren Ergebnis
abhängig ist, bzw. auf das Ergebnis wartet.
Eine Funktionseinheit soll, nachdem sie die Daten bearbeitet hat, sie einfach nach
außen weiter reichen und nicht wissen, wer die Daten entgegennimmt.
Dieses Prinzip verhindert eine Koppelung zwischen den einzelnen Funktionseinheiten.

Um jedoch ein "Zusammenspiel" zwischen den einzelnen entkoppelten Einheiten zu ermöglichen, bedarf es einen oder
mehrere "Koordinatoren" welche diesem Prinzip nicht entsprechen müssen.
Nur so kann aus vielen kleinen Funktionseinheiten ein großes Ganzes werden, dass eine komplexe Aufgabe lösen kann.

Die Funktionseinheiten, die das PoMO erfüllen müssen nennt Ralf Westphal Operationen und die Koordinatoren nennt er
Integrationen. Als Regel zusammengefasst nennt er dies "Integration Operation Segregation Principle" kurz IOSP.


*** DRAFT IOSP ( Integration Operation Segregation Principle)

Dieses Prinzip besagt, dass eine Funktionseinheit entweder eine Operation oder eine Integration ist und beide
Verantwortungsbereiche nicht vermischt werden dürfen.

**** Operationen
Operationen sind Methoden, die Logik/ Kontrollstrukturen enthalten dürfen. In C# wären das:
- if, else
- switch, case
- for, foreach,
- while, do
- try, catch, finally
- goto




Gleichzeitig müssen die Operationen das PoMO Prinzip erfüllen, sie dürfen keine
andere Funktionseinheiten kennen ( gemeint ist, sie über ihrer eigentlichen
Namen aufzurufen) oder auf das Ergebnis einer zu warten.
Ein Funktionsaufruf ist nur über Actions ( Funktionszeiger ), die man als Funktionsparameter mit übergibt, oder Events möglich.
Beide dürfen keine Rückgabewerte haben, was bei Actions implizit der Fall ist.
Damit erfüllt die Operation weiter das PoMO, da sie nicht selbst bestimmt, welche Funktion sie aufruft, sondern die Funktion,
welche die Operation aufgerufen hat ( und somit automatisch eine Integration sein muss, welche die PoMO Bedingung nicht erfüllen muss).


Operationen sind also imperative programmiert. Imperative Programmierung ist ein Programmierstill,
mit dem Fokus auf das *wie* ein Problem gelöst werden soll.
Im Gegensatz dazu steht der deklarative Ansatz.
Beim deklarativen Programmieren steht der Fokus auf das *was* getan werden soll und nicht so sehr,
wie es im Detail genau angestellt wird. Ein Beispiel hierfür wären zum Beispiel SQL Befehle.
Hier wird nur gesagt, was man haben möchte und das Programm kann dann die Anfrage nochmal untersuchen
und selbst bestimmen, wie es die Anfrage am besten ausführt.

**** FRAGEN Integrationen

Die Integrationen werden nach Flow Design Richtlinien deklarative programmiert.
Diese Funktionseinheiten dürfen anders als die Operationen, andere Funktionen aufrufen, sie also kennen.
Die Integrationen erfüllen also nicht das /Principle of Mutual Exclusion/
Der Unterschied beim Flow Design ist jedoch, dass eine bewusste Trennung eingehalten wird.

Integrationen dürfen auch auf die Terminierung einer Funktion warten und den Rückgabewert  weiterreichen an andere Funktionen.
Dafür dürfen sie keine Logik im Sinne von Kontrollstrukturen beinhalten.
Auch dürfen sie keine API-spezifischen Befehle kennen, (kein Zugriff auf
persitente Daten in Integrationen /Filehandles?).

Die Businesslogik, das was die Funktionalität erzeugt, diese befinden sich in Operationen und sind entkoppelt von ihrer Umgebung.
Sie bekommen einfach nur von irgendwo her einen Input (bzw. bei keinen Inputparametern einfach ausgeführt werden) und führen damit die von ihnen implementierte
Logik aus und geben das Ergebnis nach außen. Beim nach außen Reichen kennt die Funktionseinheit jedoch nicht den Empfänger.

*** DONE Tabelle -  IOSP auf einen Blick
CLOSED: [2016-09-08 Do 13:54]

|                                                         | Operationen | Integrationen |
|---------------------------------------------------------+-------------+---------------|
| Rechenoperationen ( +, *, %, ... )                      | Ja          | Nein          |
| Kontrollstrukturen (if, else, while, for, foreach, ...) | Ja          | Nein          |
| API-Aufrufe (Methoden von Bibliotheken)                 | Ja          | Nein          |
| Ressourcen-Zugriffe (Dateien, Datenbanken etc.)         | Ja          | Nein          |
| Standard Library, LINQ                                  | Ja          | Ja            |
| Namen andere Funktion kennen                            | Nein        | Ja            |
| Auf Rückgabewert warten                                 | Nein        | Ja            |



** DONE Beispiel foreach und Funktionsaufruf als negativ Beispiel.
CLOSED: [2016-09-08 Do 14:26]
#+BEGIN_SRC cpp
static void FormatAndPrintStrings(List<string> lines)
{
   foreach(line in lines)
   {
      string s = MyComplexFormattingFunction(line);
      Console.WriteLine(s);
   }
}

#+END_SRC
Derartiger Code wird wohl in den meisten C#-Codebasen zu finden sein und doch ist er nach Flow Design Richtlinien falsch.

In diesem Beispiel wurde Logik (foreach) gemischt mit einem expliziten Funktionsaufruf einer Funktion.
Diese Funktion ist somit nicht IOSP konform.

Es ist etwas ungewohnt, das Trennen von Integrationen und Operationen im Code auch zu berücksichtigen.
Eine For-Schleife über eine Collection laufen zu lassen und jedes Element an eine Unterfunktion weiterzureichen ist etwas,
was wohl viele Programmierer regelmässig so schreiben.
Das so etwas nun nicht mehr erlaubt ist, braucht eine gewissen Umgewöhnungszeit.


Hier nun die Umsetzung in Flow Design mit einfachsten Mitteln.



#+BEGIN_SRC cpp
static void FormatAndPrintStrings(List<string> lines)
{
   List<string> formattedLines = FormatLines(lines);
   PrintLines(formattedLines);
}

static List<string> FormatLines(List<string> lines)
{
    List<string> result = new List<string>();
    foreach(line in lines)
    {
          string formattedstring;
          // do complex formatting here
          result.Add(formattedstring)
    }
    return result;
}

static void PrintLines(List<string> lines)
{
   foreach(line in lines)
   {
      Console.WriteLine(line);
   }
}
#+END_SRC

Die Funktion wurde aufgeteilt in eine Integration (=FormatAndPrintStrings=) und zwei Operationen.
Im ersten Beispiel hat die Funktion zwei Aufgaben erfüllt, sie hat die Formatierung-Funktion integriert und
das Ergebnis ausgegeben.

Nun sind Integration, Ausgabe und Formatierung sauber getrennt.
Jedoch wurde der Code nun deutlich länger. Die Foreach-Schleife ist in beide Operationen gelandet und das Initialisieren und
Befüllen der temporären Liste in =FormatLines= nimmt auch etwas Platz ein.
Dazu kommt noch, das die String-Formattierungslogik nun eingebettet in dieser Foreach-Schleife liegt, welche vorher getrennt in
einer extra Funktion sich befand.

Elegantere Lösungen mit Actions

#+BEGIN_SRC cpp
static void FormatAndPrintStrings(List<string> lines)
{
   IterateOverLines(lines, onLine=PrintFormat );
}

static void  PrintFormat(string line)
{
    var fl = MyComplexFormattingFunction(line);
    Console.WriteLine(fl);
}

static void IterateOverLines(IEnumerable<string> lines, Action<string> onLine)
{
   foreach(line in lines)
   {
      onLine(line);
   }
}

#+END_SRC

Noch eleganter mit Actions und Lambdas

#+BEGIN_SRC cpp
static void FormatAndPrintStrings(List<string> lines)
{
  IterateOverLines(lines,
    line => {
      var fl = MyComplexFormattingFunction(line);
      Console.WriteLine(fl);
  });
}

static void IterateOverLines(IEnumerable<string> lines, Action<string> onLine)
{
   foreach(line in lines)
   {
      onLine(line);
   }
}
#+END_SRC


Elegantere Lösungen?

Es gibt zwei Möglichkeiten: Die erste Möglichkeit besteht darin, die Richtlinien etwas aufzulockern und eine Kategorie "Helfer-Funktionen" einzuführen.
Diese Funktionen haben den Status von API-Funktion. Somit wäre das erste Beispiel IOSP konform und die Funktion =FormatAndPrintStrings=
würde als Operation gelten.
Dabei stellt sich jedoch die Frage, welche Kriterien eine Funktion erfüllen muss, damit sie unter diese Kategorie
fällt, was sich als eine nicht ganz triviale Frage herausstellt.

Die zweite Möglichkeit besteht darin auf Datenfluss orientierte Sprachfeatures zu verwenden.
Somit hängt diese Möglichkeit stark von der verwendetet Programmiersprache ab.

In C# existiert eine Kategorie an Methoden, die speziell auf das Arbeiten mit Datenflüssen ausgerichtet ist, diese werden
zusammengefasst unter dem Namen LINQ (Language-Integrated Query).

Mit Hilfe von LINQ lässt sich obiges Beispiel zu einem IOSP konformen Einzeiler reduzieren.

#+BEGIN_SRC cpp
static void FormatAndPrintStrings(List<string> lines)
{
   lines.Select( x => MyComplexFormattingFunction(x)).ForEach( x => Console.Writeline(x));
}

#+END_SRC
Man könnte sich nun darüber streiten, was man nun damit gewonnen hat. Schließlich enthält die Funktion mit LINQ im Grunde
genommen fast nun genau die selbe Logik, wie das erste Beispiel, nur mit einer anderen Schreibweise.
Den Nutzen dieser Regel erschließt sich erst, bei größeren Codebasen und kommt bei kleinen Beispielen oft nicht zum Vorschein.
Erst wenn die Integrationen mehr mache, als nur eine Funktion aufrufen, wird das Entkoppeln nützlich.
Außerdem ist der Fall einer Foreach-Schleife und ein Funktionsaufruf eine Koppelung, die nicht so dramatisch ist. Man
könnte für diesen Fall sogar eine Ausnahme machen und sie erlauben.


Zusammenfassend könnte man noch sagen, dass eine größere Lesbarkeit von IOSP konformen Programmcode entsteht, umso mehr moderne
Features eine Sprache hat (??? )
** C# Features um Datenflüsse zu implementieren
Um nach Flow Design Regeln zu programmieren, helfen einem in C# einige Features die in diesem Kapitel vorgestellt werden.

*** DRAFT LINQ und Lambdas
Laut Flow Design Richtlinien ist es erlaubt die Funktionen der
Standardbibliothek der Sprache sowohl in Operationen als auch in Integrationen
zu verwenden. LINQ ist eine in C# integrierte Ansammlung an Funktionen die in Verbindung mit
Objekten, die das IEnumerable Interface implementieren, eingesetzt werden
können.
IEnumerable ist das Interface einer Containerklasse. Daran lässt sich bereits erahnen, dass LINQ
auf das Arbeiten mit Datenflüssen spezialisiert ist.

In den meisten Fällen werden den LINQ Methoden ein Lambda-Ausdruck übergeben.
Dieser wird auch als =Selector= bezeichnet, oder im Falle von Bedingungen als =Predicate=.
Lambda-Ausdrücke sind in Integrationen nur dann erlaubt, wenn die Lambdafuntkion
selbst nur eine Integration ist.

LINQ besteht aus ca. 150 Methoden.
Eine (nicht vollständige Liste) findet sich hier.
https://msdn.microsoft.com/en-us/library/system.linq.enumerable_methods(v=vs.110).aspx

Im Folgendem werden hier nur ein paar der häufigsten verwendeten Methoden erläutert.

**** Modifizieren
Folgende Methoden verändern den Datenstrom und liefern einen neuen Datenstrom
zurück (mit Ausnahme von ForEach).
| Select                        | Selektiert jedes Element und der Sequenz und modifiziert es. Zurückgegeben wird eine Sequenz der modifizierten Elemente                                                                                                                |
| ForEach (nur für List-Klasse) | Iteriert über die Sequenz und führt mit jedem Element den Selector-Ausdruck aus. Im Gegensatz zu Select wird kein Sequenz zurückgeliefert                                                                                             |
| First,  Last                  | Gibt das erste/letzte Element der Sequenz zurück, das eine bestimmte Bedingung erfüllt.                                                                                                                                                |
| OrderBy                       | Ordnet die Sequenz mit Hilfe eines =keySelector=-Ausdrucks. Dieser bestimmt das Sortierkriterium. In manchen Fällen (Elemente sind Zahlenwerte, oder Strings), kann dieser weggelassen werden, falls das Default-Verhalten gewünscht ist |
| Distinct                      | Duplikate werden aus der Sequenz gelöst.                                                                                                                                                                                               |
| Join                          | Zwei Sequenzen werden zu einer zusammengefasst                                                                                                                                                                                          |

**** Filtern
| Where                         | Filtern der Sequenz anhand des Predicate. Zurückgegeben wird eine Sequenz von Elementen, die das Filterkriterium entsprachen.                |
**** Überprüfungen
Diese Methoden liefern einen Boolean als Rückgabewert zurück.
| Any      | Wendet auf jedes Element den Selector-Ausdruck an,solange, bis bei einem Element der Ausdruck wahr wird. Dann wird =true= zurückgegeben, ansonsten =false=                                                      |
| Contains | Ähnlich wie =Any=, nur dass kein Selector übergeben wird, sondern ein Element, der selben Klasse, wie die Elemente des Containers. Befindet sich das Element in dem Container, dann wird =true= zurückgeben, ansonsten =false= |
| All      | Ähnlich wie =Any= mit dem Unterschied, dass nur dann =true= zurückgeben wird, wenn für alle Elemente des Containers der Ausdruck wahr ist.                                                                               |
**** Berechnungen
Bei Container mit Zahlenwerten (=int=, =float=, =decimal=,...) als Elementen,
können nachfolgende Funktionen ohne zusätzliche Parameter aufgerufen werden.
Falls dies nicht der Fall ist, muss ein Selector-Ausdruck, wahlweise als
Lambda-Ausdruck, mit übergeben werden. Mit dem Selector kann bestimmt werden, wie
die mathematische Rechenoperationen mit jedem Element umzugehen hat.
| Sum     | Aufsummieren der Elemente                                    |
| Max     | Gibt das Element mit dem höchsten Wert zurück                |
| Min     | Gibt das Element mit dem niedrigsten Wert zurück     |
| Count   | Zählt die Elemente des Containers und gibt die Anzahl zurück |
| Average | Berechnet den Durchschnitt der Sequenz                      |
**** Überspringen und Nehmen
Diese Methoden liefern genau wie die modifizierenden Methoden als Rückgabewert
eine neue Sequenz an Daten zurück.
| TakeWhile | Nimmt Elemente solange aus dem Container, bis eine Bedingung erfüllt ist. Es wird eine Sequenz von allen genommenen Elementen zurückgegeben                                                 |
| Skip      | Überspringt eine Anzahl an Elementen                                                                                                                                                         |
| SkipWhile | Überspringt die ersten Elemente einer Sequenz, solange bis bis die Bedingung von einem Element nicht erfüllt wird, dann wird ohne weitere Überprüfungen der Rest der Sequenz zurückgegeben |
**** Konvertieren
Sequenzen können mit Hilfe eines einfach Methodenaufrufs zu einem bestimmten Typ
von Container konvertiert werden. Zum Beispiel: =ToList= oder =ToDictionary=.

**** Parallele Verarbeitung
Datenströme können von LINQ auch parallel verarbeitet werden. Dazu konvertiert
man die Sequenz mit =toParallel()= zu einem PLINQ Datenstrom.
Anschließend ausgeführte Methoden werden, falls möglich parallel verarbeitet.

**** Referenzen
Referenz: https://www.dotnetperls.com/linq

*** DRAFT yield return
Hiermit kann man ein Producer-Consumer Pattern implementieren.
Voraussetzung ist jedoch, dass man mit Daten arbeitet, die das =IEnumerable= Interface implementieren, wie zum Beispiel die
=List= Klasse.

Das folgende Flow Design soll mit =yield return= realisiert werden.

#+CAPTION: http://www.code-whisperer.de/preview/2015/06/14/eva/
[[./img/FlowDesign2.png]]


Das Programm ist eine Konsolenanwendung, die den Benutzer eine Eingabe erlaubt.
Wenn die Eingabe die Zahl 42 entspricht, wird das Programm beendet, wenn nicht,
dann wird die Zahl ausgegeben und der Benutzer kann wieder eine Zahl eingeben.
Das wiederholt sich, solange bis der Benutzer die Zahl 42 eingetippt hat.


**** FRAGEN Erläuterung des Schaubildes
Die Main Funktion wird nach dem Programmstart ( leerer Kreis ) ohne Parameter aufgerufen.
Danach ruft diese die Funktion =ReadNumbersFromCmd= auf, welche aus der Konsole eine Eingabe ließt und sie
zu einem int parset. Der int nimmt die Main Funktion entgegen und gibt diesen an FindtheAnswer weiter.
Diese Funktion hat die Aufgabe den entgegengenommenen int mit der Zahl 42 zu vergleichen. Wenn die Zahl 42 ist, wird der Datenstrom
abgebrochen. Wenn es nicht die 42 war, dann wird der int nach außen gereicht und die Main Funktion reicht die Zahl an die
PrintNumber Funktion weiter. PrintNumber gibt die Zahl in die Konsole aus.
Wenn der Datenstrom abbricht, returned die Mainfunktion und das Programm wird beendet.
FRAGE: Was bedeutet nochmal die Tonne, mit Hand?

**** DONE Implementation
CLOSED: [2016-09-08 Do 14:14]

#+BEGIN_SRC cpp
class Program
{
  static void Main()
  {
    IEnumerable<int> numbers = ReadNumbersFromCmd();
    IEnumerable<int> answer = FindTheAnswer(numbers);
    PrintNumbers(answer);
  }

  public static IEnumerable<int> ReadNumbersFromCmd()
  {
    while (true)
    {
      var line = Console.ReadLine();
      yield return int.Parse(line);
    }
  }

  private static IEnumerable<int> FindTheAnswer(IEnumerable<int> numbers)
  {
    return numbers.TakeWhile(x => x != 42);
  }

  private static void PrintNumbers(IEnumerable<int> numbers)
  {
    foreach (var number in numbers)
    {
      Console.WriteLine(number);
    }
  }
}
#+END_SRC

Der Producer ist in dem Fall der =ReadNumbersFromCmd=.
Dieser produziert ein endloser Stream an =int=-Daten.
Es wird jedoch immer nur ein Element erzeugt und erst nachdem der Consumer das
Element abgefragt hat, wird ein neues Element erzeugt.
Wenn nichts mehr konsumiert wird, wird auch nichts mehr produziert.
Den Abbruch der Endlosschleife ( also das Stoppen des Datenflusses) kann somit auch eine andere Funktion außerhalb der Schleife
übernehmen.




** FRAGEN Datenströme mit mehreren Wegen
*** Ein Output-Weg mehrere Empfänger
[[./img/diagramOut1to2.png]]

Falls ein Output an mehrere Empfänger weitergereicht werden soll, so lässt sich das am besten mit Events realisieren.
Leider bedarf es dann bei der Benutzung der API mehr Vorsicht, da man sich vorher auf ein Events registrieren muss, bevor man
die gewünschte Funktion aufrufen kann.
Alternativ kann auch die übergeordnete Integration den Rückgabewert an die
anderen Beiden weiterreichen, oder über Actions (FRAGE: Liste aus Actions
übergeben?).

*** DRAFT Mehrere Output-Wege

[[./img/diagramOut2.png]]

Wenn eine Funktion mehrere Output-Wege hat, so kann man das im Code nicht mehr mit einem einfachen Rückgabewert implementieren.
Wäre es für eine Operation erlaubt eine andere Funktionseinheit zu kennen, dann könnten wir natürlich einfach in der Operation selbst
die nachfolgenden Methoden per Namen aufrufen. Da aber Operationen entkoppelt von ihrer Umwelt sein sollen, müssen die möglichen
Outputwege über die Argumente der Methode mitgegeben werden. Somit werden die Verantwortlichkeiten bewahrt und die übergeordnete
Integration koordiniert weiter den Datenfluss und die Operation kennt keine anderen Funktionseinheiten.

Alternativ könnte man auch hier Events nutzen, was aber durch das zusätzliche
Registrieren auf das Event eher nicht zu empfehlen ist, wenn absehbar ist, dass
nicht mehrere Funktionseinheiten gleichzeitig das Ergebnis empfangen sollen.

*** FRAGEN mit und/oder den Kontrollfluss notieren.
Wenn man möchte, so kann man den Kontrollfluss, auch in das Diagramm hier mit
dazu nehmen. Man kann in den Winkel der beiden Pfeile notieren, ob beide
Datenflüsse fließen, oder immer nur einer,

FRAGE;
1) XOR , OR ,...
2) Kann man eine Implementationsregel davon ableiten?
   Wenn ich ein UND habe, dann kann der Strom als Tupel/Datentyp realisiert
   werden. Dann muss die Integration einfach nur den ersten Teil an die eine
   Methode weiterreichen und den zweiten Teil an die andere.
   Wenn es es ODER ist, dann sind gelten ähnliche Regeln, wie für Optionale
   Outpute.
   Ich muss eine Action mitgeben. (Oder Datentypen, die null sein dürfen?)

** Weitere Beispiele was erlaubt ist und was nicht erlaubt ist.
*** DONE Rückgabewert erwarten von Funktion als Parameter übergeben.
CLOSED: [2016-09-08 Do 14:08]
In C# gibt es neben den =Actions=, die keine Rückgabewerte erlauben, auch Funktionszeiger, die einen Rückgabewert erlauben.
Diese werden mit =Func<Parameter,...,Rückgabewert>= deklariert.
Die Func würde zwar das IOSP erfüllen, die Operation würde die andere Funktion nicht kennen,
jedoch würde trotzdem eine funktionale Abhängigkeit entstehen und somit ist die untenstehende Funktion nicht Flow Design konform.

#+BEGIN_SRC cpp
static List<string> FormatStrings(List<string> lines , Func<string,string> formatFunc )
{
   List<string> result = new List<string>();
   foreach(line in lines)
   {
      string formattedstring = formatFunc(line);
      result.Add(formattedstring)
   }
   return result;
}


#+END_SRC


*** FRAGEN API-Aufruf, Filehandling?, Daten in Integrationen?

Was ist erlaubt in Integrationen?

#+BEGIN_SRC cpp
static void Foo ()
{

   var json = http.get(adress);

   Person p = new Person();
   p.name = "Peter"

   with (var f = File.Open(path))
   {
      dosomething();
   }
   OtherFunc();
}

#+END_SRC

** Warum macht man das? Sinn der Aufteilung.
*** DRAFT Die Perlenkette
Die Codebasis, die nach IOSP implementiert wurde, so bildlich gesprochen einer
Perlenkette ähneln. Der Code besteht aus aneinandergereihte Funktionseinheiten,
die zusammen ein großes Ganzes bilden. Möchte man Änderungen an dem Programm
vornehmen, so brauch man nur an einer Stelle die Kette zu öffnen und etwas
hinzufügen oder entfernen. Danach schließt man die Kette wieder und das Programm
läuft wieder. Beim einfügen oder entfernen ist nur darauf zu achten, dass die
Eingänge und Ausgänge zueinander passen. Ist das nicht der Fall, so kann man das
entweder durch eine weitere dazwischengeschoben "Adapter"-Funktionseinheit
beheben, oder man ändern die anschließenden Funktionseinheiten und deren
Eingänge und Ausgänge entsprechend um.
Die erste Variante bringt möglicherweise einen Performanceverlust mit sich.
In vielen Stellen des Codes, ist dies jedoch meistens kein Problem.
Falls die Funktionseinheiten an anderer Stelle verwendet werden, ist
möglicherweise auch eine Abänderung nicht einfach umzusetzen.

*** FRAGEN Größtes Übel funktionale Abhängigkeiten.
Funktionale Abhängigkeiten sind im echten Leben auch ein Problem, wenn es um
produktive Arbeitsabläufe geht.
Wenn jemand seine Arbeit erst zu Ende bringen kann, wenn ein anderer seine Arbeit
getan hat, ist das schlecht.
Besser ist es, wenn eine Person sich von einem Pool an Aufgaben bedienen kann,
sie unabhängig von anderen Personen erledigen kann und dann das Ergebnis wieder
in ein Pool zurückgibt, von denen sich andere wieder bedienen können.


*** Optional
-  nochmal rückbesinnen auf CCD
** DRAFT Ausnahmen
Generell gilt die Regel, wenn ich mich bewusst an einer Stelle gegen die IOSP
Regel entscheide, ist dann in Ordnung, solange ich es gut begründen kann.
Es gibt jedoch bereits einige Fälle, wo sich ein Aufheben der Regel als gut
herausgestellt hat.
*** FRAGEN Rekursion
Operationen dürfen sich selber aufrufen.
Was ist mit einer Kette von Operationen, wo die letzte Operation die Rekursion startet?
*** DONE Integrationen
CLOSED: [2016-09-08 Do 14:08]
**** DONE Try / Catch
CLOSED: [2016-09-08 Do 14:08]
Oft braucht man auf oberster Ebene, einen Try/Catch, der alle Exceptions abfangen soll, und eine generelle Fehlerbehandlungsroutine
startet. Hier bleibt einem nichts anderes übrig, als die Regel keine Logik in den Integrationen zu haben, etwas aufzuweichen.

**** DONE LINQ / Standard-Library Funktionen
CLOSED: [2016-09-08 Do 14:08]
Manche Funktionalitäten, die die Sprache selbst bereitstellt, können streng genommen als API-Aufrufe bezeichnet werden
. Jedoch gilt hier eine Ausnahme. Man darf auch in Integrationen diese Funktionalität verwenden.
Beispiele aus C#:
=int.TryParse= , =List<>.Sort=, =Dictionary<>.Insert=, ...


** FRAGEN Zusammenfassung

   Tabelle:
   Daten - Methoden in Daten-Objekte aufrufen? Darf Operation die Methode kennen?
   Daten - was bedeutet die eigentlich? Methoden die zum Datentyp
   gehören/gekapselt sind, sind die in Operationen erlaubt? file open handlers?
   Daten - Darf Integration wirklich Konstruktor aufrufen, das sind doch Daten, oder gelten nur persistente Daten?



** Leserlichkeit
In diesem Kapitel werde ich mich speziell mit der Frage der Lesbarkeit mancher Flow Design Implementationen beschäftigen.
Ziel von CCD ist es nicht nur den Code evolvierbar zu halten, sondern ihn auch besser leserlich zu machen.

*** Integration gibt Funktionszeiger an Operationen, welche diesen jedoch auch nur an die nächste Operation weitergibt.
Auf Ebene der Integration, wo man eigentlich das Zusammenspiel der einzelnen Operationen leicht erkennen soll, ist es bei solch einem Beispiel den
Fluss nachzuvollziehen.

-> main ->
->DecideValidationProcess -> Validation -> DoSomething ->

Lösung: erstellen einer weiteren Integration, die die beiden letzten Operationen integriert.
-> main ->
-> DecideValidationProcess -> Validation1AndDoSomething ->
                          -> Validation -> DoSomething ->


* Die Entwurfsmethode

** TODO System-Umwelt-Diagramm
    Man zeichnet ein Kreis auf ein Papier, diese stellt die Domäne dar.
    Auf der linken Seite hängt man die Sachen dran, die auf die Domäne zugreifen sogenannte Portale, zum Beispiel HTTP-Zugriff,
    Batch mode, oder GUIs.
    Auf der anderen Seite sind die Provider, diese Stellen externe Ressourcen zur Verfügung, die die Domäne verwendet.
    Ziel ist es später in der Implementierung darauf zu achten, dass die "Schicht" oder "Membran", zwischen Domäne und Außenwelt möglichst
dünn bleibt. Somit lässt sich die Domäne besser testen und es lassen sich leichter neue Portale und Provider anhängen.

** TODO Interfaceskizze ( im Falle einer GUI Anwendung )
Man zeichnet eine einfache Skizze der GUI auf ein Papier und überlegt sich, welche Interaktionen kann der Nutzer machen.
Diese Interaktionen werden dann gesammelt und für jedes wird dann ein eigenes Flow Design erstellt.

** TODO Flow Design Entwurf
Herauskristallisieren der einzelnen Funktionseinheiten und welche Daten von wo nach wo fließen.

** FRAGEN Einordnen der Funktionseinheiten in bestimmte Container

Mit Container meint man: Klassen, DLL, Anwendungen.
Man fasst eine oder mehrere Funktionseinheiten zusammen, indem mag zum Beispiel alle mit einer gestrichelten Linie einkreist oder alle die zur selben Klasse
gehören farblich markiert. Der Name der Klasse notiert man dann im eingekreisten Feld oder unter jeder Funktionseinheit.
  endet mit Einteilen in Klassen, DLL, Anwendungen,...

  Entwurf ist ein Interaktiver Prozess, somit wäre Roundtrip super "Sinn des Systems SharpFlowDesign erläutern"

1)FRAGE: Manchmal wird eine Funktionseinheit selbst als Klasse implementiert? Dann kann ich sie ja nicht in eine andere Klasse schieben.

** FRAGEN Optional - Bestimmen von Parallelitäten
Es können zusätzlich noch Pfeile eingefärbt werden, um zu verdeutlichen, dass
manche Datenströme parallel laufen können.
FRAGE: Wie genau geht das?
* TODO Rekursive Eigenschaft
Das Schöne an Flow Design und dem Konzept der Softwarezelle ist, dass sie rekursive ist.
Man kann das Problem/die Anwendung ganz oben als eine Softwarezelle (oder hier der Kreis mit den Providern? ist das auch eine Softwarezelle?)
verstehen, indem links Portale Zugriffe machen und rechts davon, die Softwarezelle wiederum auf ihre Provider Zugriffe macht.
Die einzelnen Aktionen aus dem die Anwendung besteht können wiederum als Softwarezellen verstanden werden, auf die von links
der Zugriff und der Input in die Softwarezelle hineinkommen, die Softwarezelle bearbeitet die Anfrage und rechts von ihr, kommt das
Ergebnis heraus. Die Interaktion kann wiederum wieder in kleiner Teile zerlegt werden, die alle eine Softwarezelle sind, mit Inputs und
Outputs. Damit ist die Architektur weniger starr, als zum Beispiel das Schichtenmodell oder das Zwiebelschalenmodell ( laut Ralf Westphal ).



* Backlog
** Einfaches Beispiel eines Flow Designs
*** Negativ Beispiel
#+BEGIN_SRC cpp
...
static void Main()
{
   while (true)
   {
      int number = ReadNumberFromCmd();
      bool isAnswer = FindTheAnswer(number);

      if (isAnswer)
         break;
      else
         PrintNumber(number);
   }
}

static int ReadNumbersFromCmd()
{
    var line = Console.ReadLine();
    int number = int.Parse(line);
    return number;
}

static bool FindtheAnswer(int number)
{
    if (number == 42)
        return true;
    return false;
}
...
#+END_SRC
