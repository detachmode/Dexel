* Flow Design Vorstellung
** Entstehung und Grundgedanke
Flow Design ist aus der Clean Code Development Bewegung heraus entstanden. Hauptinitiatior und Erfinder ist Ralf Westphal.
Ralf Westphal war auch Mitbegründer und Miterfinder der Clean Code Developement Bewegung.


Clean Code Development ist eine Ansammlung aus Prinzipen, die einem helfen sollen wartbare Software zu schreiben.
Wartbare bedeutet Änderungen an der Software sollen leicht zu realisieren sein und der Programmcode soll
am besten auch leicht zu lesen bleiben.
Prinzipien sind jedoch nicht so leicht einzuhalten, wie konkrete Regeln, welche man einfach einhalten kann.
Somit ist es in der Praxis schwer die Prinzipen auf den eigenen Code anzuwenden.
Flow Design soll in Ergänzung eine Methodik und Programmierregeln bieten, die man einfach befolgen kann und man erhält automatisch
ein Code, der die CCD Prinzipen erfüllt.

Im Hauptfokus liegen vorallem folgende Prinzipien von CCD:
- Lose Koppelung
- Orthogonalität
  
Weitere Prinzipien die Beachtung find sollen:
- Separation of Concerns
- Single Responsibility Principle
- Information Hiding Principle 
- Dependecy Injection
- Interface Segregation Principle

Flow Design ist eine Entwurfsmethode, die im Gegensatz zu UML besser geeignet sein soll, bereits in der Entwurfsphase Anwendung zu finden.
Ziel ist es sich auf dem Papier bereits ein Entwurf der Programmstruktur überlegen zu können.
Aktuell sei es aus der Mode gekommen, vor dem Programmieren einen Entwurf zu erzeugen, was vorallem daran läge, dass die vorhandenen
Entwurfsmethodiken eher hinderlich seien und einen unnötigen Overhead erzeugen ( laut Ralf Westphal)
Es sei somit üblich geworden die Denkearbeit, wie man seinen Code möglichst sauber strukturien kann,
während dem Programmieren direkt im/vor dem Sourcecode zu verrichten.
Dies sei jedoch laut Ralf Westphal eine eher ungünstige Lösung und behindere eher den kreativen Denkprozess mit
unnötiger Schreibarbeit.
Auf dem Papier sei man mit einer passenden Entwurfsmethodik schneller und man könne auch verschiedene Ideen schneller
ausprobieren, Änderungen machen, oder auch wieder verwerfen, als direkt im Sourcecode. 

Es geht jedoch nicht darum den Sourcecode bis ins kleinste Detail in eine Art visuelle Programmiesprache zu pressen,
sondern darum, wie man den Code am sinnvollsten in Funktionseinheiten zerlegt (die einen möglichst aussagekräftigen Namen haben sollten).
Wie die Funktionalität auf unterster Ebene implementiert wird, wird auf dem Diagramm nicht berücksichtigt.
Das ist jedoch keine negative Einschränkung, vielmehr ermöglicht dies, sich auf beim Entwurf nicht mit unnötigen Implementierungsdetails bechäftigen zu 
müssen, sonder sich auf das Große ganze - das Zusammenspiel/ Komposition der Funktionseinheiten und den Datenfluss zu konzentrieren.

Anzumerken wäre noch, dass nicht der Kontrollfluss abgebildet wird, sondern, wie erwähnt, der Datenfluss.

** Einfaches Beispiel eines Flow Designs

[[./img/FlowDesign2.png]]

http://www.code-whisperer.de/preview/2015/06/14/eva/

Das Programm ist eine Konsolenanwedung, die den Benutzer eine Eingabe erlaubt.
Wenn die Eingabe die Zahl 42 entspricht, wird das Programm beendet, wenn nicht, kann wieder eine Zahl eingeben werden.
Das wiederholt sich, solange bis der Benuter die Zahl 42 eingetippt hat.

*** Erläuterung der Notation
Alle eingekreisten Namen sind Funktionseinheiten, oder auch Softwarezelle genannt.
Diese werden üblicherweise im Code als Funktionen implementiert.
Die Pfeile zeigen den Datenstrom. Links die Inputs und rechts die Outputs.
Eine leere Klammer bedeutet, dass keine Daten fließen.
In diesem Fall hat die Funktion stattdessen oft eine Tonne, die anzeigt, dass die Funktionseinheit state-behaftet ist.
Wenn die Tonne zusätzlich noch mit einer Linie verbunden ist, an dessen Ende ein Kreis gezeichnet ist,
dann bedeutet das, dass die Funktion auf externe Resourcen zugreift. 
Den Kreis kann man sich bildlich wie eine Hand vorstellen, an die sich die Funktion festhält.

Ein Stern innerhalb der Klammern der Datenströme, bedeutet, dass 0..n Daten dieses Types zwischen
den Funktionseinheiten fließen können.
Je nach Programmiersprache, kann man das Verhalten mit einem yield in einer Schleife realisieren, 
oder mit einer Liste/Array als Rückgabewert. 

Die Main Funktion ruft die anderen 3 Funktionen auf, eine Funktionseinheit die andere Funktionseinheiten aufruft,
werden als Integrationen bezeichnet. Die anderen 3 Methoden rufen selbst keine anderen Funktionseinheiten auf und werden
Operationen genannt. Anhand einer Flow Design Skizze, kann man leicht herausfinden, welche Funktionen Operationen sind und welche
Integrationen.
Alle Leaf-Knoten sind Operationen, der Rest sind Integrationen.
*** Finale Erklärung
Die Main Funktion wird nach dem Programmstart ( leerer Kreis ) ohne Parameter aufgerufen.
Danach ruft diese die Funktion ReadNumbersFromCmd auf, welche aus der Konsole eine Eingabe ließt und sie
zu einem int parset. Der int nimmt die Main Funktion entgegen und gibt diesen an FindtheAnswer weiter.
Diese Funktion hat die Aufgabe den entgegengenommenen int mit der Zahl 42 zu vergleichen. Wenn die Zahl 42 ist, wird der Datenstrom 
abgebrochen. Wenn es nicht die 42 war, dann wird der int nach außen gereicht und die Main Funktion reicht die Zahl an die 
PrintNumber Funktion weiter. PrintNumber gibt die Zahl in die Konsole aus.  
Wenn der Datenstrom abbricht, returned die Mainfunktion und das Programm wird beendet.
FRAGE: Was bedeutet nochmal die Tonne, mit Hand?


** IODA Architekur
IODA steht für: Integration Operation Data API

[[./img/ioda1.png]]
http://blog.ralfw.de/2015/04/die-ioda-architektur.html

*** Funktionale Abhängigkeiten vermeiden


*** PoMO ( Principle of Mutual Oblivion)
    Ein Producer
    kennt seinen Consumer nicht. Ein Consumer kennt seinen Producer
    nicht. Das nenne ich das Principle of Mutual Oblivion (PoMO,
    Prinzip der gegenseitigen Nichtbeachtung) (architect napkin, Seite 80)

Dieses Prinzip besagt, dass Funktionseinheiten sich nicht gegenseitig kennen sollen.
Es soll auch verhindert werden, dass eine Einheit eine andere aufruft und von deren Ergebnis
abhängig ist, bzw. auf das Ergebnis wartet. 
Eine Funktionseinheit soll, nachdem sie die Daten bearbeitet hat, sie einfach nach 
außen weiter reichen und nicht wissen, wer die Daten entgegennimmt.
Dieses Prinzip verhindert eine Koppelung zwischen den einzelnen Funktionseinheiten.

Um jedoch ein "Zusammenspiel" zwischen den einzelnen entkoppelten Einheiten zu ermöglichen, bedarf es einen oder
mehrere "Koordinatoren" welche diesem Prinzip nicht entsprechen müssen.
Nur so kann aus vielen kleinen Funktionseinheiten ein großes Ganzes werden, dass eine komplexe Aufgabe lösen kann.

Die Funktionseinheiten, die das PoMO erfüllen müssen nennt Ralf Westphal Operationen und die Koordinatoren nennt er 
Integrationen. Als Regel zusammengefasst nennt er dies "Integration Operation Segregation Principle" kurz IOSP.


*** IOSP ( Integration Operation Segregation Principle)

Dieses Prinzip besagt, dass eine Funktioneseinheit entweder eine Operation oder eine Integration ist und beide 
Verantwortungsberreiche nicht vermischt werden dürfen.

**** Operationen
Operationen sind Funktionen, die Logik/ Kontrollstrukturen enthalten dürfen. In C# wären das:
- if, else
- for, foreach,
- while, do
- try, catch
- .. vollständig?

Gleichzeitig müssen die Operationen das PoMO prinzip erfüllen, sie dürfen keine andere Funktionseinheiten kennen oder aufrufen und auf
das Ergebnis warten.
Ein Funktionsaufruf ist nur über Actions ( Funktionspointer ), die man als Funktionsparameter mit übergibt, oder Events möglich.
Damit erfüllt die Operation weiter das PoMO, da sie nicht selbst bestimmt, welche Funktion sie aufruft, sondern die Funktion, welche die
Operation aufgrufen hat ( und somit automatisch eine Integration sein muss, welche die PoMO Bedingung nicht erfüllen muss).


Operationen sind also imperative programmiert. Imperative Programmierung ist ein Programmierstill, mit dem Fokus auf das WIE ein Problem gelöst werden
soll. Im Gegensatz dazu steht der Deklarative Ansatz. Beim deklarativen Programmieren steht der Fokus auf das WAS getan werden soll und nicht so sehr, wie es
im Detail genau angestellt wird. Ein Beispiel hierfür wären zum Beispiel SQL Befehle. Hier wird nur gesagt, was man haben möchte und das Programm kann dann
die Anfrage nochmal untersuchen und selbst bestimmen, wie es die Anfrage am besten ausführt.

**** Integrationen
Die Integrationen werden nach Flow Design Richtlinien deklarative programmiert.
Diese Funktioneneinheiten dürfen anders als die Operationen, andere Funktionen aufrufen, sie also kennen.  
Der Unterschied beim Flow Design ist jedoch, dass eine bewusste Trennung eingehalten wird.

Integrationen dürfen auch  auf die Terminierung einer Funktion warten und den Rückgabewert  weiterreichen an andere Funktionen.
Dafür dürfen sie keine Logik im Sinne von Kontrollstrukturen beinhalten. 

Die Businesslogik, das was die Funktionalität erzeugt, diese befinden sich in Operationen und sind entkoppelt von ihrer Umgebung.
Sie bekommen einfach nur von irgendwo her einen Input (bzw bei keinen Inputparametern einfach ausgeführt werden) und führen damit die von ihnen implementierte
Logik aus und geben das Ergebnis nach außen. Beim nach außen Reichen kennt die Funktionseinheit jedoch nicht den Empfänger.

**** Ausnahmen / Einschränkungen
***** Operationen 
****** API
Operationen dürfen API aufrufe machen, was zwar ein Koppelung darstellt, gleichzeitig ist es aber auch ein Gewinn, wenn die Koppelung
sich hier nur auf unterester Ebene auswirken, und sich diese API Logik nicht bis in die Integrationen hoch verstrickt.
API-Aufrufe gehören zu den Provider und sollen sich möglichst nicht weit in die Domänelogik hinein ausbreiten.
****** Standard-Library Funktionen
Funktionen, die von der Sprache selbst bereitgestellt werden, dürfen auch in den Operationen verwendet werden.
Beispiele aus C#:
FRAGE: Linq auch in Operationen erlaubt?
int.TryParse, math.sqrt, ... 
***** Integrationen

****** Try / Catch
Oft braucht man auf oberster Ebene, einen Try/Catch, der alle Exceptions abfangen soll, und eine generelle Fehlerbehandlungsroutine 
startet. Hier bleibt einem nichts anderes übrig, als die Regel keine Logik in den Integrationen zu haben, etwas aufzuweichen.


**** Tabelle -  IOSP auf einen Blick


|                                                         | Operationen | Integrationen        |
| Rechenoperationen ( +, *, %, ... )                      | Ja          | Nein                 |
| Kontrollstrukturen (if, else, while, for, foreach, ...) | Ja          | Nein                 |
| try, catch                                              | Ja          | Nein( mit Ausnahmen) |
| API-Aufrufe (Methoden von Bibliotheken)                 | Ja          | Nein                 |
| Ressourcen-Zugriffe (Dateien, Datenbanken etc.)         | Ja          | Nein                 |
| Standard Library, LINQ                                  | Ja          | Ja                   |
| Namen andere Funktion kennen                            | Nein        | Ja                   |
| Auf Rückgabewert warten                                 | Nein        | Ja                   |

** Der komplette Ablauf
*** Definieren der Portale und Provider
    Man zeichnet ein Kreis auf ein Papier, diese stellt die Domäne dar.
    Auf der linken Seite hängt man die Sachen dran, die auf die Domände zugreifen so gegannte Portale, zum Beispiel HTTP-Zugriff,
    Batch mode, oder GUIs.
    Auf der anderen Seite sind die Provider, diese Stellen externe Resourcen zur Verfügung, die die Domäne verwendet.
    Ziel ist es später in der Implementierung darauf zu achten, dass die "Schicht" oder "Membran", zwischen Domäne und Außenwelt möglichst
dünn bleibt. Somit lässt sich die Domäne besser testen und es lassen sich leichter neue Portale und Provider anhängen.

*** Interfaceskizze ( im Falle einer GUI Anwendung )
Man zeichnet eine einfache Skizze der GUI auf ein Papier und überlegt sich, welche Interaktionen kann der Nutzer machen.
Diese Interaktionen werden dann gesammelt und für jedes wird dann ein eigenes Flow Design erstellt.

*** Flow Design Entwurf
Herauskristallisieren der einzelnen Funktionseinheiten und welche Daten von wo nach wo fließen.

*** Einordnen der Funktionseinheiten in bestimmte Klassen 
Man fasst eine oder mehere Funktionseinheiten zusammen, indem man zum Beispiel alle mit einer gestrichelten Linie einkreist oder alle die zur selben Klasse
gehören farblich markiert. Der Name der Klasse notiert man dann im eingekreisten Feld oder unter jeden Funktionseinheit.
FRAGE: Manchmal wird eine Funktionseinheit selbst als Klasse implementiert? Dann kann ich sie ja nicht in eine andere Klasse schieben.
RAGE: Schreibt man unter jeden Funktionseinheit die Klasse?



* C# 
** Features der Sprache
Um nach Flow Design Regeln zu programmieren, helfen einem in C# einige Features die in diesem Kapitel vorgestellt werden.
*** yield return 
Hiermit kann man ein Producer-Consumer Pattern implementieren. 
Vorraussetzung ist jedoch, dass man mit Daten arbeitet, die das IEnumerable Interface implementieren, wie zum Beispiel die
List Klasse.

#+BEGIN_SRC emacs-lisp
       (defun org-xor (a b)
          "Exclusive or."
          (if a (not b) b))
     #+END_SRC

*** LINQ



