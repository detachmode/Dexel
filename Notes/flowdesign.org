* Flow Design Vorstellung
** Entstehung und Grundgedanke
Flow Design ist aus der Clean Code Development Bewegung heraus entstanden. Hauptinitiatior und Erfinder ist Ralf Westphal.
Ralf Westphal war auch Mitbegründer und Miterfinder der Clean Code Developement Bewegung.

Clean Code Development besteht hauptsächlich aus Prinzipen, nicht jedoch aus Regeln, die man einfach einhalten kann.
Somit ist es in der Praxis schwer die Prinzipen auf den eigenen Code anzuwenden.
Flow Design soll in Ergänzung eine Methodik und Programmierregeln bieten, die man einfach befolgen kann und man erhält automatisch
ein Code, der die CCD Prinzipen erfüllt.

Im Hauptfokus liegen vorallem folgende Prinzipien von CCD:
- Lose Koppelung
- Orthogonalität
  
Weitere Prinzipien die Beachtung find sollen:
- Separation of Concerns
- Single Responsibility Principle
- Information Hiding Principle 
- Dependecy Injection
- Interface Segregation Principle

FlowDesign ist eine Entwurfsmethode, die im Gegensatz zu UML besser geeignet sein soll, bereits in der Entwurfsphase Anwendung zu finden.
Ziel ist es sich auf dem Papier bereits ein Entwurf der Programmstruktur überlegen zu können.
Aktuell sei es aus der Mode gekommen, vor dem Programmieren einen Entwurf zu erzeugen, was vorallem daran läge, dass die vorhandenen
Entwurfsmethodiken eher hinderlich seien und einen unnötigen Overhead erzeugen ( laut Ralf Westphal)
Es sei somit üblich geworden die Denkearbeit, wie man seinen Code möglichst sauber strukturien kann,
während dem Programmieren direkt im/vor dem Sourcecode zu verrichten.
Dies sei jedoch laut Ralf Westphal eine eher ungünstige Lösung und behindere eher den kreativen Denkprozess mit
unnötiger Schreibarbeit.
Auf dem Papier sei man mit einer passenden Entwurfsmethodik schneller und man könne auch verschiedene Ideen schneller
ausprobieren, Änderungen machen, oder auch wieder verwerfen, als direkt im Sourcecode. 

Es geht jedoch nicht darum den Sourcecode bis ins kleinste Detail in eine Art visuelle Programmiesprache zu pressen,
sondern darum, wie man den Code am sinnvollsten in Funktionseinheiten zerlegt (die einen möglichst aussagekräftigen Namen haben sollten).
Wie die Funktionalität auf unterster Ebene implementiert wird, wird auf dem Diagramm nicht berücksichtigt.
Das ist jedoch keine negative Einschränkung, vielmehr ermöglicht dies, sich auf beim Entwurf nicht mit unnötigen Implementierungsdetails bechäftigen zu 
müssen, sonder sich auf das Große ganze - das Zusammenspiel/ Komposition der Funktionseinheiten und den Datenfluss zu konzentrieren.

** Der grobe Ablauf
*** Definieren der Portale und Provider
    Man zeichnet ein Kreis auf ein Papier, diese stellt die Domäne dar.
    Auf der linken Seite hängt man die Sachen dran, die auf die Domände zugreifen so gegannte Portale, zum Beispiel HTTP-Zugriff,
    Batch mode, oder GUIs.
    Auf der anderen Seite sind die Provider, diese Stellen externe Resourcen zur Verfügung, die die Domäne verwendet.
    Ziel ist es später in der Implementierung darauf zu achten, dass die "Schicht" oder "Membran", zwischen Domäne und Außenwelt möglichst
dünn bleibt. Somit lässt sich die Domäne besser testen und es lassen sich leichter neue Portale und Provider anhängen.

*** Interfaceskizze ( im Falle einer GUI Anwendung )
Man zeichnet eine einfache Skizze der GUI auf ein Papier und überlegt sich, welche Interaktionen kann der Nutzer machen.
Diese Interaktionen werden dann gesammelt und für jedes wird dann ein eigenes Flow Design erstellt.

*** Flow Design Entwurf
Herauskristallisieren der einzelnen Funktionseinheiten und welche Daten von wo nach wo fließen.

*** Einordnen der Funktionseinheiten in bestimmte Klassen 
Man fasst eine oder mehere Funktionseinheiten zusammen, indem man zum Beispiel alle mit einer gestrichelten Linie einkreist oder alle die zur selben Klasse
gehören farblich markiert. Der Name der Klasse notiert man dann im eingekreisten Feld oder unter jeden Funktionseinheit.
FRAGE: Manchmal wird eine Funktionseinheit selbst als Klasse implementiert? Dann kann ich sie ja nicht in eine andere Klasse schieben.
RAGE: Schreibt man unter jeden Funktionseinheit die Klasse?

*** Das Diagramm
Im Fokus stehen dabei Funktioneneinheien und Datenflüsse, nicht jedoch der Kontrollfluss.
Die einzelnen Funktioneneinheiten haben ein oder mehrere Input und Output Flüsse.


* Principles
** PoMO ( Principle of Mutual Oblivion)
Dieses Prinzip besagt, dass Funktionseinheiten sich nicht gegenseitig kennen sollen.
Es soll auch verhindert werden, dass eine Einheit eine andere aufruft und von deren Ergebnis
abhängig ist, bzw. auf das Ergebnis wartet. 
Eine Funktionseinheit soll, nachdem sie die Daten bearbeitet hat, sie einfach nach 
außen weiter reichen und nicht wissen, wer die Daten entgegennimmt.

Dieses Prinzip verhindert eine Koppelung zwischen den einzelnen Funktionseinheiten.
Um das zu erreichen, gibt es eine Programmierregel, die es ermöglicht, beim Programmieren darauf zu achten,
das dieses Prinzip eingehalten wird.
Um jedoch ein "Zusammenspiel" zwischen den einzelnen entkoppelten Einheiten zu ermöglichen, bedarf es einen oder
mehrere "Koordinatoren" welche diesem Prinzip nicht entsprechen müssen.
Nur so kann aus vielen kleinen Funktionseinheiten ein großes Ganzes werden, dass eine komplexe Aufgabe lösen kann.

Die Funktionseinheiten, die das PoMO erfüllen müssen nennt Ralf Westphal Operationen und die Koordinatoren nennt er 
Integrationen. Als Regel zusammengefasst nennt er dies "Integration Operation Segregation Principle" kurz IOSP.


** IOSP ( Integration Operation Segregation Principle)
Dieses Prinzip besagt, dass eine Funktioneseinheit entweder eine Operation oder eine Integration ist und beide 
Verantwortungsberreiche nicht vermischt werden dürfen.

*** Operationen
Operationen sind Funktionen, die Logik/ Kontrollstrukturen enthalten dürfen. In C# wären das:
- if, else
- for, foreach,
- while, do
- try, catch
- .. vollständig?

Gleichzeitig müssen die Operationen das PoMO prinzip erfüllen, sie dürfen keine andere Funktionseinheiten kennen oder aufrufen und auf
das Ergebnis warten.
Ein Funktionsaufruf ist nur über Actions ( Funktionspointer ), die man als Funktionsparameter mit übergibt, oder Events möglich.
Damit erfüllt die Operation weiter das PoMO, da sie nicht selbst bestimmt, welche Funktion sie aufruft, sondern die Funktion, welche die
Operation aufgrufen hat ( und somit automatisch eine Integration sein muss, welche die PoMO Bedingung nicht erfüllen muss).


Operationen sind also imperative programmiert. Imperative Programmierung ist ein Programmierstill, mit dem Fokus auf das WIE ein Problem gelöst werden
soll. Im Gegensatz dazu steht der Deklarative Ansatz. Beim deklarativen Programmieren steht der Fokus auf das WAS getan werden soll und nicht so sehr, wie es
im Detail genau angestellt wird. Ein Beispiel hierfür wären zum Beispiel SQL Befehle. Hier wird nur gesagt, was man haben möchte und das Programm kann dann
die Anfrage nochmal untersuchen und selbst bestimmen, wie es die Anfrage am besten ausführt.

*** Integrationen
Die Integrationen werden nach Flow Design Richtlinien deklarative programmiert.
Diese Funktioneneinheiten dürfen anders als die Operationen, andere Funktionen aufrufen, sie also kennen.  
Der Unterschied beim Flow Design ist jedoch, dass eine bewusste Trennung eingehalten wird.

Integrationen dürfen auch  auf die Terminierung einer Funktion warten und den Rückgabewert  weiterreichen an andere Funktionen.
Dafür dürfen sie keine Logik im Sinne von Kontrollstrukturen beinhalten. 

Die Businesslogik, das was die Funktionalität erzeugt, diese befinden sich in Operationen und sind entkoppelt von ihrer Umgebung.
Sie bekommen einfach nur von irgendwo her einen Input (bzw bei keinen Inputparametern einfach ausgeführt werden) und führen damit die von ihnen implementierte
Logik aus und geben das Ergebnis nach außen. Beim nach außen Reichen kennt die Funktionseinheit jedoch nicht den Empfänger.

*** Ausnahmen / Einschränkungen
**** Operationen 
***** API
Operationen dürfen API aufrufe machen, was zwar ein Koppelung darstellt, gleichzeitig ist es aber auch ein Gewinn, wenn die Koppelung
sich hier nur auf unterester Ebene auswirken, und sich diese API Logik nicht bis in die Integrationen hoch verstrickt.
API-Aufrufe gehören zu den Provider und sollen sich möglichst nicht weit in die Domänelogik hinein ausbreiten.
***** Standard-Library Funktionen
Auch Funktionen, die von der Sprache selbst bereitgestellt werden, dürfen sowohl auch in den Operationen verwendet werden.
Beispiele aus C#:
FRAGE: Linq auch in Operationen erlaubt?
int.TryParse, math.sqrt, ... 
**** Integrationenk

***** Try / Catch
Oft braucht man auf oberster Ebene, einen Try/Catch, der alle Exceptions abfangen soll, und eine generelle Fehlerbehandlungsroutine 
startet. Hier ist es doch ratsam, die Regel keine Logik in den Integrationen zu haben, etwas aufzuweichen.

*** Übersicht
|                              | Operationen | Integrationen     |
| if,else                      | O           | -                 |
| for, foreach                 | O           | -                 |
| while, do                    | O           | -                 |
| try, catch                   | O           | nur mit Ausnahmen |
| API Aufrufe                  | O           | -                 |
| Standard Library, LINQ       | O           | O                 |
| Namen andere Funktion kennen | -           | O                 |
| Auf Rückgabewert warten      | -           | O                 |
*
