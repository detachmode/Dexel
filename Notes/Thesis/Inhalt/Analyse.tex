
\section{Vision}

Im Grunde geht es bei einem Editor für Flow Design vor allem darum die Vorteile aus der digitalen Welt mit
der Methodik zu vereinen, ohne die Einfachheit der Methodik auf dem Papier zu
verlieren. 

\subsection{Vorteile eines digitalen Editors}

Flow Design ist eigentlich als Entwurfsmethode auf dem Papier gedacht.
Jedoch hat ein Flow Design auf dem Papier einige Nachteile, die ein Editor am
Computer aufheben könnte. Das wären vor allem folgende Punkte:
\subsubsection{Einmal eingezeichnete Pfeile, Kreise und Beschriftungen lassen sich nicht so leicht mehr verändern.}

Während des kreativen Prozesses ein Programmierproblem zu lösen, bedarf es
mehrere Iterationen und Veränderungen an dem Diagramm. Eine Möglichkeit Versionen
abzuspeichern und Teile zu verschieben, umzubenennen und umzustrukturieren sind
klare Vorteile von einem digitalen Editor.
\subsubsection{Automatische Validierungsprozesse}

Während der Erstellung des Flow Designs können im Hintergrund
Validierungsprozesse beim Erstellen des Diagrammes Hilfestellung bieten.
Autovervollständigungen könnten ebenfalls an einigen Stellen eingebaut werden,
um das Tippen zu beschleunigen.
\subsubsection{Unnötige Abtipparbeit ersparen}

Aus den Beschriftungen im Flow Design Diagramm lassen sich die Variablennamen und
Methoden Signaturen leicht herleiten. Liegt das Diagramm in digitaler Form vor,
wäre eine automatische Generierung von Quellcode naheliegend und
würde dem Anwender unnötige Abtipparbeit ersparen.
\subsubsection{Generierung von Methoden-Bodies}

Durch die strikten Implementierungsregeln von Integrationen lassen sich von
diesen Methoden nicht nur die Signaturen, sonder sogar die komplette Implementierung aus dem Diagramm
ableiten. Eine Generierung dieser Codezeilen wäre ein zusätzlicher Komfortgewinn von einem Editor.
\subsubsection{Roundtrip-Engineering}

Eine Möglichkeit aus einer bestehenden Codebasis ein Diagramm zu erstellen -
wenn auch nur teilweise - würden die Produktivität beim Einsetzen von Flow
Design in einem Projekt weiter steigern. Aufgrund von Unterhaltungen mit meinem
Anleiter Kevin Erath stellte sich heraus, dass ein perfekter Roundtrip umzusetzen keine triviale Aufgabe
darstellt. Deswegen wird im Rahmen dieser Arbeit der Fokus auf jene Funktionalitäten
gelegt, die leichter zu implementieren sind und doch dem Anwender möglichst viel
Zeitersparnis einbringt. Ein Anwendungsfall wäre: Der Anwender möchte
Teile seines Quellcodes in ein Flow Design überführen, um dann mit Hilfe des
Flow Designs, diesen zu überarbeiten und anschließend neu zu generieren.
Möglicherweise würde er die erstellten Codezeilen mit Copy-Paste in sein
bestehendes Projekt übertragen.

\subsection{Vorteile von einem Entwurf auf dem Papier}

Ein Papier schränkt einen nicht ein und erlaubt es schnell und einfach Pfeile
und Kreise zu zeichnen, Notizen einzufügen und ist einfach in der Bedienung.
Bei dem Erstellen eine Editors muss deshalb ein besonders großes Augenmerk auf
eine gute und intuitive Bedienung gelegt werden, damit einem das Programm bei der kreativen Arbeit nicht
behindert. Endziel wäre es, dass der Anwender von sich aus lieber zum Editor
greift, als zu Stift und Papier, weil ihm der Editor komfortableres und
kreatives Arbeiten besser ermöglicht.

\section{Anforderungen}

\subsection{Editor}

\begin{center}
\begin{tabular}{ll}
Anforderungen & Priorität\\
\hline
Erstellen von Softwarezellen, Benennen, Verschieben auf dem Canvas, Löschen, Duplizieren & must have\\
Navigation ( Panning, Zooming ) & must have\\
Selektieren von mehreren Softwarezellen um mehrere auf einmal zu bearbeiten & must have\\
Definieren von Input und Output Datastreams, für eine Softwarezelle & must have\\
Verbinden eines Outputs einer Softwarezelle mit einem Input einer anderen & must have\\
Zusammenlaufen von mehreren Datenflüssen in ein Input einer Softwarezelle & must have\\
Softwarezelle(n) einer anderen unterordnen können, um Integrationen zu erstellen inklusive visuelle Kennzeichnung & must have\\
Syntaxhighlighting für die Datentypen auf den Datenflüssen & nice to have\\
Mehrere Themes: Dark, White (Print) & nice to have\\
Keyboard Hotkeys / Tabstops & nice to have\\
Kommentarboxen & nice to have\\
Automatisches Spacing & nice to have\\
Untergeordenete Softwarezellen einer Integration an einer anderen Stelle definierbar machen, falls Platz knapp wird & nice to have\\
Speichern und Laden in ein Dateiformat & must have\\
Autosave & must have\\
Undo / Redo System & nice to have\\
Definieren von State einer Softwarezelle & nice to have\\
Mouse-Hover zeigt Preview des erzeugten Codes für die Softwarezelle & nice to have\\
Wiederverwenden von vorhandenen Softwarezellen & nice to have\\
Autocomplete auf dem Textfeld der Datenströme & nice to have\\
Definieren von neuen Datentypen & nice to have\\
Validierung von Datenströmen & must have\\
Anfügen von Tests an Softwarezelle & nice to have\\
\end{tabular}
\end{center}

\subsubsection{Anmerkungen}
\label{sec:orgheadline10}
\begin{enumerate}
\item Navigation
\label{sec:orgheadline9}
Durch Inspiration aus Grafikanwendungen: Panning ( Verschieben der Kamera in
der X- und Y-Achse mit Hilfe der Mittleren Maustaste. Zoomen in und aus dem
Diagramm durch das Mausrad. Die Position der Maus bestimmt das Zentrum des
Zooms.
\end{enumerate}




\subsection{Generierung von Code}
\label{sec:orgheadline16}
\begin{center}
\begin{tabular}{ll}
Anforderungen & Priorität\\
\hline
Generierung von Methodensignaturen aus dem Namen und Input/Output Definitionen einer Softwarezelle & must have\\
Erzeugen des kompletten Methoden-Bodies einer Integration & must have\\
Live-Generierung & nice to have\\
Erzeugung von Klassen und Datentypen & nice to have\\
Erzeugung von Namenspaces und Auflösung von Usings & nice to have\\
Einstellungen  dem Benutzer zugänglich machen, um die Generierung zu konfigurieren & nice to have\\
Korrektes Einfügen / Integrieren von den generierten Codezeilen in die Codebasis eines bestehendes Softwareprojektes & nice to have\\
\end{tabular}
\end{center}
\subsubsection{Anmerkungen}

\begin{enumerate}
\item Erzeugung des kompletten Methoden-Bodies einer Integration

Hierbei muss erkannt werden, in welcher Reihenfolge die Methoden aufgerufen
werden müssen, lokale Variablen erzeugt werden müssen und was einer Methode als Parameter
übergeben werden muss. Dabei kommen \textit{IEnumerables} und Lambdas zum Einsatz um
Datenflüsse zu implementieren. 

\item Einstellungen für die Generierung dem Benutzer zugänglich machen

Mögliche Optionen wären:
\begin{itemize}
\item wie das Programm den Methoden-Body einer Operation
standardmäßig befüllen soll: Leer, mit \textit{NotImplementedExeption} oder mit einem 
Rückgabeausdruck eines Standardwertes abhängig von der Methodensignatur. 

\item Ob innerhalb einer Integration der Rückgabewert einer Funktion erst in eine
lokale Variable gespeichert werden soll, oder direkt der Methodenaufruf an die
andere Methode weitergereicht wird, bzw. diese Regel konfigurierbar
machen:
\begin{itemize} 
	\item ab welcher Zeilenlänge eine lokale Variable erstellt werden soll
	\item wie die Variablen benannt werden sollen, etc.	
\end{itemize}

\end{itemize}

\item Einfügen von generierten Codezeilen in bestehende Codebasis

Notwendig hierfür wäre, dass bestehende Klassen gefunden werden müssten, Usings korrekt
eingefügt und schlussendlich die generierten Methoden und Datentypen in die
jeweiligen Klassen / Dateien eingefügt werden. Dabei muss die Syntax
berücksichtigt werden und möglicherweise Zugriffsberechtigungen erkannt und bei
Problemen einen Dialog zur Korrektur dem Anwender anbieten. Weiteres Problem
wäre die Überschneidung von Namen. Wenn automatisch der generierte Code bevorzugt
  werden soll, dann könnten durch die Überschreibung von Datentypen und Methoden
  bestehende Codezeilen plötzlich fehlerhaft werden. Ein extra Dialog wäre
  möglich, würde jedoch den Aufwand zur Integration des Codes möglicherweise stark
  anheben. Ebenso wäre ein solcher Dialog aufwendig zu implementieren.
  Eine andere Option wäre es, diese einfach einzufügen und die Erkennung und Lösung der
  Probleme der IDE zu überlassen. Gerade bei C\# gibt es mit Resharper viele
  Refactorisierungs-Tools, die einem bei der Lösung solcher Probleme unterstützen.
\end{enumerate}


\subsection{Generierung von Flow Design Diagrammen aus Code}


\begin{center}
\begin{tabular}{ll}
Anforderungen & Priorität\\
\hline
Finden von Methoden und Erzeugen von Softwarezellen und ihre Input und Output Datenströme anhand der Methodensignatur im Code & must have\\
Erkennen, ob es sich bei der Methode um eine Operation oder Integration handelt & must habe\\
Den Datenfluss einer Integration erkennen und ihn in ein Flow Design Diagramm übertragen & must have\\
Umgang mit Methoden die nicht das IOSP befolgen & nice to have\\
Automatisches Spacing & must have ( aber nicht unbedingt perfekt)\\
Speichern der Inhalte, die nicht im Diagramm dargestellt werden können. & nice to have\\
\end{tabular}
\end{center}

\subsubsection{Anmerkungen}

\begin{enumerate}
\item Automatische Anordnung

Unbedingt notwendig, auch wenn es nur sehr rudimentär umgesetzt wird, ansonsten liegen
alle Softwarezellen nach dem Erstellen unübersichtlich auf einem Punkt aufeinander.
Falls das Automatische Spacing an manchen Stellen nicht perfekt funktionieren
sollte, kann eine gute Usability ( Selektierungs- und Verschiebungsfeatures)
hier dieser Imperfektion leichter verschmerzbarer machen.

\item Schwierigkeiten

Bei Verwendung von Events kann der Datenfluss möglicherweise nicht mehr
nachvollzogen werden.
\end{enumerate}


\section{GUI Skizzen / Usabilityüberlegungen}


\subsection{Minimalistischer Aufbau. Fokus auf Produktivität.}

Im folgendem einige Kerngedanken über die Funktionalität des Editors:

\begin{itemize}
\item Keine unnötigen Menüleisten, Symbolleisten, etc. Besser kontextsensitive
Kontextmenüs, oder Hotkeys,  damit die Strecke, die die Maus bewegt werden muss, gering
gehalten wird.
\item Tabulatorstopps einbauen, damit schnell zwischen den Textfeldern, entlang des
Graphen, gesprungen werden kann.
\item Verwendung von Drag and Drop, um eine intuitive Bedienung zum Verknüpfen von
Softwarezellen zu ermöglichen. Die Flächen, die per Drag and Drop zu Bedienen
sind, sollen über ein Mouse-Hover Feedback erkennbar sein. Außerdem sollen die
Flächen nicht zu klein sein, damit ein leichtes Treffen des Feldes
sichergestellt wird. Möglicherweise können auch unsichtbare Flächen verwendet
werden, um eine Drag and Drop Fläche künstlich leicht zu vergrößern und einfacher treffbar zu machen.
\item Rectangle Selection in Kombination mit Modifier-Keys um mehrere Softwarezellen
schnell und komfortable zu selektieren.
\item Shift + Drag : Schnelles Duplizieren der selektierten Objekte. Vorbild dieser
Funktion ist 3ds Max, das dieses Bedienkonzept an vielen Stellen einsetzt.
Einmal daran gewöhnt, möchte man es nicht mehr missen. Anwendungsfälle:
Der Anwender möchte  schnell ein gesamtes Diagramm duplizieren und an ein andere Stelle schieben, um
dort eine weitere Iteration davon zu erstellen. Möglicherweise müssen solche
Duplikate vor der Generierung des Codes aus dem Diagramm gelöscht werden.
Ein andere Anwendungsfall von Duplizierten ist, dass der Anwender eine vorhandene
Zelle an einer anderen Stelle im Diagramm verwendet möchte. Damit
entstehen weitere Probleme, bei der Generierung des Codes, das gelöst werden
muss: Duplizierte Softwarezellen müssen erkannt und nur einmal generiert werden.
\item Ctrl + Drag einer Softwarezelle: Die Softwarezelle und alle ihre Kinder werden
Verschoben. Anwendungsfall ist: Der Anwender möchte etwas Platz schaffen
zwsichen zwei Softwarezellen. Mit einem Ctrl+ Drag der zweiten Softwarezelle,
kann er diese und alle nachkommenden Softwarezellen verschieben, ohne sie
vorher extra selektieren zu müssen.
\end{itemize}

\subsection{Textfelder}

Textfelder müssen waagerecht bleiben. Auf dem Papier schreibt man die Daten auf
die Pfeile, somit wird Text auf einem schrägen Pfeil auch entlang des Striches
geschrieben.
Am Computer ist so etwas schlecht umzusetzen. Man kann Textfelder bei WPF drehen, dadurch
entsteht jedoch eine ungewohnte Bedienung beim Markieren von Text. Ein Drehen
beim Fokussieren/Defokussieren wäre auch möglich, damit wäre jedoch eine zusätzlicher
Klick nötig, falls man Text markieren möchte: Ein Mausklick zum Fokussieren/Drehen
der Textbox und ein weiterer um Text zu markieren / den Cursor zu platzieren.
Die beste Lösung wäre aus Usability-Sicht, wenn Textfelder nicht gedreht werden,
sondern immer waagerecht dargestellt werden. Somit muss hier die Notation an
manchen Stellen etwas vom original Abweichen.
\begin{itemize}
\item Mehrere Outputs
\item Pfeile zwischen zwei Softwarezellen, die auf unterschiedlichen Höhen platziert
sind.
\end{itemize}

\subsection{Datentypen Organisation, Erstellung und Definition}

Da Flow Design auf Datenströmen arbeitet, ist das Definieren neuer Datentypen
ein wesentlicher Bestandteil davon.
Eine Möglichkeit wäre es, wie auf dem Papier, es zu erlauben an beliebigen
Stellen im Diagramm eine Box zu erstellen, in der der Anwender einen neuen
Datentyp benennen und seine Felder definieren kann. Vorteil davon wäre, dass der
Anwender die nötige Information in der Nähe des Datenstroms schnell ersichtlich
dort platzieren kann, wo die Daten auch vorkommen.
Nachteil wäre, dass das automatische Spacing zusätzlich komplizierter
wird, da nun auch eine sinnvolle Platzierung der Datentypen nun mit
berücksichtigt werden muss.

Ein weiteres Problem dieser Lösung taucht auf, wenn man an unterschiedlichen
Positionen im Diagramm eine Datentypen verwendet. In diesem Fall müssten Doppelungen erlaubt
sein, oder der Anwender würde an einer Stelle nicht die Information haben, worum
es sich bei einem Datentyp handelt.

Eine andere Option wäre es, die Datentypen nicht auf dem \textit{DrawingBoard} zu
platzieren, sondern separate vom Flow Design getrennt in einem extra GUI-Element
darzustellen und dort die Definition neuer Typen zu ermöglichen.
Dieses GUI-Element würde in Form einer Liste alle vorhanden Datentypen
beinhalten. Zusätzliche Usability-Features wären, das Typen, die im Diagramm
vorkommen, jedoch nicht zu den Basistypen der Sprache gehören und noch nicht in
der Anwendung definiert wurden, erkannt und speziell hervorgehoben werden und
den Anwender subtil auffordert diesen zu definieren.

Um den Vorteil einer Box innerhalb des Diagrammes etwas zu entkräften, könnten
die Einträge in der Liste kontextsensitiv sein: Wenn der Anwender in ein
Textfeld eines Datenstromes klickt, könnte die Liste nur jene Datentypen
anzeigen, die in dem Textfeld vorhanden sind. Beim klick auf eine leere Fläche (
defokussieren des Textfeldes) würden wieder alle Datentypen im gesamten Diagramm
angezeigt werden.

Weitere Ideen: 
\begin{itemize}
\item Mouse-Hover über ein Datentype im Diagramm zeigt die Definition in einem Pop-Up
über dem Mauszeiger an.
\item Drag and Drop von Datentypen aus der Liste in das DrawingBoard zu
ermöglichen, falls der Anwender für einen Screenshot - oder aus einem anderen
Grund - diese Information im Bild haben möchte.
\end{itemize}


\subsection{Realisierung/ Darstellung von Joints}

Datenströme können aus verschieden Quellen stammen und an einer Softwarezelle
zusammenlaufen. Flow Design bietet hierfür die Pipe-Notation, oder die s.g. Joints
an. 

Vorteile der Pipe-Notation / Nachteile der Joints:

\begin{itemize}
\item Einfacher zu realisieren auf GUI Seite ( Automatisches Spacing aufgrund der
geringeren Anzahl an Pfeilen einfacher umzusetzen
\item Pfeile müssen seltener große Distanzen überbrücken, was das Diagramm weniger
chaotisch wirken lässt
\end{itemize}

Nachteile der Pipe-Notation / Vorteile der Joints:

\begin{itemize}
\item Datenströme sind möglicherweise nicht mehr eindeutig zu interpretieren. Bei
der Verwendung von Joints ist die Herkunft eines Datenstroms eindeutig
ersichtlich. Bei der Pipe-Notation kann man diese Problem durch eine Benennung
der Datenströme lösen. Diese Erkenntnis legt eine Validierung - einschließlich
visuellem Feedback - der Datenströme auf eine eindeutige Interpretation nahe.
Eine andere Option wäre, dass man beim Generieren den Datenstrom zurück läuft
und das erste Vorkommen nimmt und nachfolgende Überschneidungen ignoriert.
\end{itemize}


\subsection{Validierung des Datenflusses}

Der Validierungsprozess soll subtil sein. Ein Blockieren von verbinden zweier
Softwarezellen soll nicht geschehen. Diese würde sonst dem Ziel entgegen stehen, 
eine mögliche freie Gestaltung, wie beim Zeichnen auf dem Papier, zu
gewährleisten. Der Anwender soll die Freiheit haben, nicht valide Verbindungen
zu erstellen, die er möglicherweise nach dem Verbinden dann entsprechend
anpasst. Eine dezente farbliche Hervorhebung soll als Feedback des
Validierungsprozesses ( möglicherweise indem man den Pfeil einfärbt) ausreichen. Mögliche Validierungsfehler wären:
\begin{itemize}
\item Pipe-Notation : Überschneidung von Datentypen.
\item Fehlende Daten : Nicht alle vom Input der Softwarezelle verlangten Daten
sind im Datenfluss enthalten.
\end{itemize}

Im Grunde wäre jedoch auch eine Generierung von jeglichem Flow Design Diagrammen
möglich, würde man folgende Regeln einführen:
\begin{itemize}
\item Pipe-Notation: Der Graph wird zurück gelaufen, bis ein passender Datentype
gefunden wurde ( Das erste Vorkommen wird genommen). Falls der Datentyp nicht
gefunden wurde, wird er in der Integration als lokale Variable deklariert und mit einem
Standardwert initialisiert.
\end{itemize}

\subsection{Validierung der Syntax}

Die Notation der Daten der Datenflüssen besteht aus einer einfachen Syntax. Diese muss zwingend eingehalten
 werden, damit eine Generierung des Codes möglich ist.
 Eine rote gewellte Linie unterhalb des nicht validen Textes hilft dem Anwender
 schnell Fehler zu erkennen.

