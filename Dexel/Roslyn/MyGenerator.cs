using System;
using System.Collections.Generic;
using System.Linq;
using Dexel.Model.DataTypes;
using Dexel.Model.Manager;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Formatting;
using Microsoft.CodeAnalysis.Editing;
using Microsoft.CodeAnalysis.Formatting;
using Roslyn.Generators;

namespace Roslyn
{
    public class MyGenerator
    {
        private readonly Workspace _workspace = new AdhocWorkspace();
        public SyntaxGenerator Generator;


        public MyGenerator()
        {
            Generator = SyntaxGenerator.GetGenerator(_workspace, LanguageNames.CSharp);
        }


        public void GenerateCodeWithNamespace(MainModel model, Action<string> onGeneratedCode)
        {
            var methods = GenerateAllMethods(model);
            var datatypes = GenerateDataTypes(model);

            var interactionsClass = GenerateClass("Interactions", members: datatypes.Concat(methods).ToArray());
            var namespaceDeclaration = Generator.NamespaceDeclaration("AutoGenerated", interactionsClass);

            GenerateCode(namespaceDeclaration, onGeneratedCode);
        }


        public IEnumerable<SyntaxNode> GenerateDataTypes(MainModel model)
        {
            return model.DataTypes.Select(dt =>
            {
                var body = CustomDataTypesGenerator.GenerateFields(Generator, dt);
                return GenerateClass(name: Helper.FirstCharToUpper(dt.Name), members: body.ToArray());
            });
        }


        public string GenerateMethods(MainModel mainModel)
        {
            var methods = GenerateAllMethods(mainModel);
            return CompileToString(methods);
        }


        public List<SyntaxNode> GenerateAllMethods(MainModel model)
        {
            var allMethods = new List<SyntaxNode>();
            GeneratedOperations(model, allMethods.Add);
            GenerateIntegrations(model, allMethods.Add);
            return allMethods;
        }


        private void GenerateIntegrations(MainModel model, Action<SyntaxNode> onMethod)
        {
            model.FunctionUnits.Where(sc => sc.IsIntegrating.Count > 0).ToList().ForEach(isc =>
            {
                var nullable = false;
                var body = IntegrationGenerator.GenerateIntegrationBody(Generator, model, isc, 
                    integrationBody => IntegrationAnalyser.NeedsLocalReturnVariable(integrationBody, () => nullable = true));

                var integration = MethodsGenerator.GenerateStaticMethod(Generator, isc, body, nullable);

                onMethod(integration);
            });
        }


        private void GeneratedOperations(MainModel mainModel, Action<SyntaxNode> onMethod)
        {
            mainModel.FunctionUnits
                .Where(functionUnit => functionUnit.IsIntegrating.Count == 0).ToList()
                .ForEach(functionUnit =>
                    onMethod(MethodsGenerator.GenerateStaticMethod(Generator, functionUnit,
                        MethodsGenerator.GetNotImplementatedException(Generator))));
        }


        public string CompileToString(List<SyntaxNode> nodes)
        {
            var cw = new AdhocWorkspace();
            var options = cw.Options;

            options = options.WithChangedOption(
                CSharpFormattingOptions.NewLinesForBracesInLambdaExpressionBody, value: false);
            var res = nodes.Select(n => Formatter.Format(n, cw, options).ToFullString())
                .Aggregate((f, s) => f + "\n\n" + s);
            return res;
        }


        public string[] CompileToStrings(List<SyntaxNode> nodes)
        {
            var cw = new AdhocWorkspace();
            var options = cw.Options;
            options = options.WithChangedOption(
                CSharpFormattingOptions.NewLinesForBracesInLambdaExpressionBody, value: false);
            var res = nodes.Select(n => Formatter.Format(n, cw, options).ToFullString());
            return res.ToArray();
        }


        private void GenerateCode(SyntaxNode namespaceDeclaration, Action<string> onGeneratedCode)
        {
            var cw = new AdhocWorkspace();
            var options = cw.Options;
            options = options.WithChangedOption(CSharpFormattingOptions.NewLinesForBracesInLambdaExpressionBody, false);

            var formattedResult = Formatter.Format(namespaceDeclaration, cw, options);
            onGeneratedCode(formattedResult.ToFullString());
        }


        public SyntaxNode GenerateClass(string name, SyntaxNode[] members)
        {
            var classDefinition = Generator.ClassDeclaration(
                name,
                typeParameters: null,
                accessibility: Accessibility.Public,
                modifiers: DeclarationModifiers.None,
                baseType: null,
                interfaceTypes: null,
                members: members
            );
            return classDefinition;
        }
    }


    public class GeneratedLocalVariable
    {
        public IEnumerable<NameType> NameTypes;
        public DataStreamDefinition Source;
        public string VariableName;
    }


    public class MethodWithParameterDependencies
    {
        public FunctionUnit OfFunctionUnit;
        public List<Parameter> Parameters = new List<Parameter>();
    }


    public enum Found
    {
        NotFound,
        FromParent,
        FoundInPreviousChild
    }


    public class Parameter
    {
        public Found FoundFlag;
        public NameType NeededNameType;
        public DataStreamDefinition Source;
        public bool AsOutput { get; set; }
    }
}